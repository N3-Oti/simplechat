--- START OF REVISED FILE 用語集.md ---

# 用語集

この用語集は、`simplechat` プロジェクトを理解する上で役立つ技術用語や AWS サービスの概念を解説します。各項目には、**初心者向けの簡単な解説**と、より**技術的な詳細解説**の二部構成で説明を加えています。

---

**API (Application Programming Interface)**
*   **初心者向け解説:** コンピュータプログラムやサービス同士が、お互いに「会話」したり、「お願い」したりするための「ルール」や「窓口」のことです。例えば、天気予報アプリが気象庁のサーバーに「今日の東京の天気は？」と問い合わせるための特別な連絡方法（窓口とルール）が API です。このプロジェクトでは、ウェブブラウザ（フロントエンド）が AWS 上のプログラム（バックエンド）に「チャットの応答をください！」とお願いする際の窓口として使われています。
*   **技術的な解説:** ソフトウェアコンポーネントが互いにやり取りするための仕様のセット。HTTP/HTTPS プロトコル上で動作する Web API が一般的で、リクエスト（要求）とレスポンス（応答）の形式（例: JSON）、エンドポイント（接続先の URL）、認証方法などが定義されます。
*   **関連:** Amazon API Gateway, REST API, HTTP

**Amazon API Gateway**
*   **初心者向け解説:** クラウド上にあるたくさんのプログラム（サービス）の「総合受付」や「ドアマン」のようなものです。外部からの「お願い」（リクエスト）をまず受け取り、誰からのリクエストかを確認（認証）し、適切な担当部署（このプロジェクトでは [AWS Lambda](#aws-lambda) の `ChatFunction`）に繋いでくれます。いわば、セキュリティチェックをして、正しい宛先に案内してくれる役割です。フロントエンドのウェブページがバックエンドのチャット機能に安全にアクセスするための門番と言えます。
*   **技術的な解説:**
    *   **定義:** API の作成、公開、保守、モニタリング、保護を大規模に行うためのフルマネージドサービスです。
    *   **プロジェクトでの役割:** フロントエンド ([axios](#axios) を使用) からの HTTP リクエストを受け付けます。受け付けたリクエストは、まず [Amazon Cognito](#amazon-cognito) オーソライザーによって認証されます（リクエストヘッダーの `Authorization` に [ID Token](#id-token-cognito) が必要です）。認証が成功すると、リクエストをバックエンドの [AWS Lambda](#aws-lambda) 関数 (`ChatFunction`) にルーティングします。このプロジェクトでは、[REST API](#rest-api) として定義され、Lambda Proxy Integration を使用しています。認証されたユーザーの情報は、Lambda 関数の `event` データ内の `requestContext.authorizer.claims` に含まれ、Lambda 関数が「どのユーザーからのリクエストか」を知ることができます。
*   **関連:** [API](#api-application-programming-interface), [REST API](#rest-api), [AWS Lambda](#aws-lambda), [Amazon Cognito](#amazon-cognito), [Lambda Proxy Integration](#api-gateway-event-lambda-proxy-integration), [axios](#axios), [Authorization Header](#authorization-header), [ID Token](#id-token-cognito)

**Amazon Bedrock**
*   **初心者向け解説:** 様々な AI 企業が作った高性能な「AI 頭脳」（大規模言語モデル、LLM）を、簡単に使えるように提供してくれるサービスです。自分で難しい AI を作る必要がなく、Amazon が用意した窓口 ([API](#api-application-programming-interface)) を通じて、文章を作ってもらったり、質問に答えてもらったりできます。このプロジェクトでは、ユーザーとのチャット応答を生成する「頭脳」として、この Bedrock を利用しています。Lambda 関数がユーザーのメッセージを Bedrock に送り、応答をもらっています。
*   **技術的な解説:**
    *   **定義:** 主要な AI 企業が提供する基盤モデル (Foundation Models, FM) や Amazon 独自のモデルを、API を通じて利用可能にするフルマネージドサービスです。
    *   **プロジェクトでの役割:** このプロジェクトの中核となるチャット機能を提供します。バックエンドの [AWS Lambda](#aws-lambda) 関数 (`ChatFunction`) が、[Boto3](#boto3) の [Bedrock Runtime Client](#bedrock-runtime-client-boto3) を使用して `invoke_model` API を呼び出し、指定されたモデル (環境変数 `MODEL_ID` で指定) と対話します。API には会話履歴と[推論パラメータ](#inference-parameters-bedrock)を含むペイロードが送信されます。
*   **関連:** [LLM (大規模言語モデル)](#llm-large-language-model), 基盤モデル (FM), [AWS Lambda](#aws-lambda), [Boto3](#boto3), [Bedrock Runtime Client](#bedrock-runtime-client-boto3), [invoke_model](#invoke_model-bedrock-api)

**Amazon CloudFront**
*   **初心者向け解説:** ウェブサイトの表示を速くするための「高速配達ネットワーク」です。ウェブサイトのデータ（文字、画像など）を、世界中に設置されたコピー保管場所（エッジロケーション）に置いておき、ユーザーがアクセスしてきたときに一番近い場所からデータを届けることで、表示速度を向上させます。このプロジェクトでは、ユーザーが見るチャット画面のデータ ([Amazon S3](#amazon-s3-simple-storage-service) に保存されている) を、この CloudFront を使って素早くユーザーのブラウザに届けています。
*   **技術的な解説:**
    *   **定義:** 高いパフォーマンス、セキュリティ、デベロッパーの利便性を備えたコンテンツ配信ネットワーク (CDN) サービスです。
    *   **プロジェクトでの役割:** フロントエンドの静的ファイル ([Amazon S3](#amazon-s3-simple-storage-service) に格納) をユーザーに近いエッジロケーションから配信することで、ウェブサイトの表示速度を向上させます。また、HTTPS 通信の強制や、シングルページアプリケーション (SPA) のためのカスタムエラーページの表示（存在しないパスへのアクセスを `index.html` に転送する）なども行います。
*   **関連:** [CDN (コンテンツ配信ネットワーク)](#cdn-content-delivery-network), [Amazon S3](#amazon-s3-simple-storage-service), [CloudFront Distribution](#cloudfront-distribution), [CloudFront Origin](#cloudfront-origin)

**Amazon Cognito**
*   **初心者向け解説:** ウェブサイトやアプリの「会員証発行・管理サービス」です。ユーザーが新しくアカウントを作ったり（サインアップ）、ログインしたり（サインイン）、パスワードを忘れたときの手続きなどを、安全かつ簡単に行う機能を提供します。このプロジェクトでは、チャットボットを使うユーザーを管理し、ログインした人だけがチャット機能を使えるようにするために Cognito を利用しています。ログインに成功すると、「身分証明書」([ID Token](#id-token-cognito)) が発行され、ユーザーはそれを使ってチャット API にアクセスします。
*   **技術的な解説:**
    *   **定義:** ウェブアプリケーションやモバイルアプリケーションに、迅速かつ容易にユーザーのサインアップ、サインイン、アクセスコントロール機能を追加できるサービスです。
    *   **プロジェクトでの役割:** ユーザー認証 (サインアップ、サインイン、パスワード管理など) を担当します。[UserPool](#userpool-cognito) でユーザー情報を管理し、[UserPool Client](#userpool-client-cognito) を介してフロントエンドアプリケーション ([AWS Amplify](#aws-amplify) ライブラリを使用) と連携します。フロントエンドでは `@aws-amplify/ui-react` の [Authenticator](#authenticator-component-amplify-ui) コンポーネントが認証 UI を提供します。認証後、フロントエンドは `Auth.currentSession()` でユーザーセッションを取得し、そこから [ID Token](#id-token-cognito) (JWT) を取得してバックエンド API ([API Gateway](#amazon-api-gateway)) 呼び出し時の `Authorization` ヘッダーに付与します。[API Gateway](#amazon-api-gateway) のオーソライザーはこのトークンを検証し、認証済みユーザーからのリクエストのみを許可します。
*   **関連:** 認証, [UserPool](#userpool-cognito), [UserPool Client](#userpool-client-cognito), [OAuth 2.0](#oauth-20), [OpenID Connect](#openid-connect-oidc), [API Gateway](#amazon-api-gateway) Authorizer, [AWS Amplify](#aws-amplify), [Amplify Auth](#amplify-auth), [Authenticator Component](#authenticator-component-amplify-ui), [ID Token](#id-token-cognito), [JWT](#jwt-json-web-token)

**Amazon S3 (Simple Storage Service)**
*   **初心者向け解説:** インターネット上にデータを保存しておくための、非常に大きくて丈夫な「オンライン倉庫」です。写真、動画、ウェブサイトのファイルなど、あらゆる種類のデータを安全に保管できます。このプロジェクトでは、ユーザーが見るチャット画面のウェブページファイル（HTML、CSS、JavaScriptなど）をこの S3 倉庫に保管しています。そして、[Amazon CloudFront](#amazon-cloudfront) という高速配達サービスを通じて、この倉庫からユーザーにファイルを届けています。
*   **技術的な解説:**
    *   **定義:** 高い耐久性、可用性、スケーラビリティを提供するオブジェクトストレージサービスです。
    *   **プロジェクトでの役割:** ビルドされたフロントエンドアプリケーションの静的ファイル (HTML, CSS, JavaScript, 画像など) を格納する場所として使用されます ([`WebsiteBucket`](#s3-bucket-deployment-cdk))。これらのファイルは [Amazon CloudFront](#amazon-cloudfront) を通じて配信されます。また、デプロイ時に生成されるフロントエンド設定ファイル (`config.js`) もこのバケットに保存されます。
*   **関連:** オブジェクトストレージ, [Amazon CloudFront](#amazon-cloudfront), [S3 Bucket Deployment](#s3-bucket-deployment-cdk), [config.js (Frontend)](#configjs-frontend)

**API Gateway Event (Lambda Proxy Integration)**
*   **初心者向け解説:** [API Gateway](#amazon-api-gateway) が受け取った「お願い」（HTTP リクエスト）の内容を、そのまま [Lambda](#aws-lambda) 関数に伝えるための「連絡メモ」のようなものです。誰が (認証情報)、何を (リクエストの内容)、どのように (HTTP メソッド、URL など) 要求しているかの詳細な情報が書かれています。Lambda 関数はこのメモを見て、要求に応じた処理を行います。
*   **技術的な解説:**
    *   **定義:** [Amazon API Gateway](#amazon-api-gateway) が Lambda Proxy Integration を使用している場合に、バックエンドの [AWS Lambda](#aws-lambda) 関数に渡されるイベントデータの構造です。HTTP リクエストに関する情報 (メソッド、パス、ヘッダー、クエリパラメータ、リクエストボディ) や、認証情報 ([Cognito](#amazon-cognito) オーソライザーからのクレームなど) が含まれます。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` の `lambda_handler` 関数が受け取る `event` 引数がこれに該当します。関数内では `event["body"]` からユーザーメッセージと会話履歴を、`event["requestContext"]["authorizer"]["claims"]` から Cognito が認証したユーザーの情報を取得しています。
*   **関連:** [Amazon API Gateway](#amazon-api-gateway), [AWS Lambda](#aws-lambda), [JSON](#json-javascript-object-notation)

**ARN (Amazon Resource Name)**
*   **初心者向け解説:** AWS 上にあるたくさんのサービスや部品（リソース）それぞれに付けられた、世界で一つだけの「住所」や「識別番号」のようなものです。どのサービスアカウントの、どの地域の、どのサービス（例: Lambda 関数）の、どのリソースかを正確に特定できます。
*   **技術的な解説:**
    *   **定義:** AWS リソースを一意に識別するためのグローバルな識別子です。`arn:partition:service:region:account-id:resource-id` のような形式を持ちます。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` の `extract_region_from_arn` 関数は、Lambda 関数の実行コンテキストから取得した自身の ARN を解析して、関数が実行されている AWS リージョン（地域）を特定しています。これは、同じ地域の Bedrock サービスに接続するために使われます。
*   **関連:** AWS リソース, 識別子

**Authenticator Component (Amplify UI)**
*   **初心者向け解説:** ウェブサイトにログイン画面やアカウント作成画面を簡単に作るための「部品セット」です。[AWS Amplify](#aws-amplify) という開発ツールキットの一部で、これを使うと、開発者は面倒なログイン画面のデザインや処理を自分で一から作らなくても、すぐに見た目が良くて安全な認証機能を追加できます。このプロジェクトでは、ユーザーがチャットを始める前にログインするための画面を提供するために使われています。
*   **技術的な解説:**
    *   **定義:** `@aws-amplify/ui-react` ライブラリが提供する [React](#react) [コンポーネント](#component-react)です。サインイン、サインアップ、パスワード忘れなどの認証フローに必要な UI を簡単に実装できます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` の `App` コンポーネントで使用されています。`<Authenticator>` でラップされた子要素（この場合は `ChatInterface` コンポーネント）は、ユーザーが認証された後にのみレンダリングされます。認証が成功すると、`<Authenticator>` は子要素に `signOut` 関数（ログアウト用）と `user` オブジェクト（ユーザー情報）を [props](#props-react) として渡します。
*   **関連:** [AWS Amplify](#aws-amplify), [Amplify UI React](#amplify-ui-react-aws-amplifyuireact), [React](#react), [Component (React)](#component-react), 認証, [Amazon Cognito](#amazon-cognito)

**Authorization Header**
*   **初心者向け解説:** インターネット通信で、自分が誰であるかを証明するための「通行証」や「身分証明書」を提示する場所（HTTP ヘッダー）のことです。ログイン後にサービスを利用する際、毎回「私はログイン済みの X さんです」と伝えるために使われます。このプロジェクトでは、Cognito からもらった「デジタル身分証明書」([ID Token](#id-token-cognito)) をこのヘッダーに入れて、API Gateway に「私は正当なユーザーですよ」と伝えています。
*   **技術的な解説:**
    *   **定義:** HTTP ヘッダーの一つで、リクエストを行うクライアントが自身を認証するための資格情報を含みます。様々な認証スキーム (Basic, Bearer など) があります。
    *   **プロジェクトでの役割:** フロントエンド ([axios](#axios)) がバックエンド API ([API Gateway](#amazon-api-gateway)) を呼び出す際に、`Authorization` ヘッダーに `Bearer` スキームで [Cognito](#amazon-cognito) から取得した [ID Token](#id-token-cognito) (JWT) を設定しています。API Gateway の Cognito オーソライザーがこのヘッダーを検証し、トークンが有効であればリクエストを許可します。
*   **関連:** HTTP Headers, 認証, Bearer Token, [ID Token](#id-token-cognito), [JWT](#jwt-json-web-token), [Amazon API Gateway](#amazon-api-gateway), [axios](#axios)

**AWS Amplify**
*   **初心者向け解説:** ウェブサイトやスマホアプリを作る人たちが、AWS の様々なサービス（認証、データ保存、API など）を簡単に組み込んで、高機能なアプリを素早く作るための「開発ツールキット」です。認証機能 ([Amazon Cognito](#amazon-cognito) と連携) や API 接続などを、少ないコードで実現できるように手助けしてくれます。このプロジェクトのフロントエンド (チャット画面) では、Cognito を使ったログイン機能の実装を簡単にするために Amplify を利用しています。
*   **技術的な解説:**
    *   **定義:** モバイルおよびフロントエンドウェブデベロッパーが、AWS を活用したスケーラブルなフルスタックアプリケーションを構築するためのライブラリ、UI コンポーネント、CLI ツール、およびコンソールを提供するフレームワークです。
    *   **プロジェクトでの役割:** フロントエンド (`simplechat/frontend/src/App.js`) では、Amplify ライブラリ (`aws-amplify`) と Amplify UI React (`@aws-amplify/ui-react`) が使用されています。`Amplify.configure()` で [Cognito](#amazon-cognito) 設定を初期化し、`Auth` モジュール ([Amplify Auth](#amplify-auth)) でユーザーセッションや [ID Token](#id-token-cognito) を取得し、[Authenticator](#authenticator-component-amplify-ui) コンポーネントで認証 UI を提供しています。関連するライブラリは `simplechat/frontend/package.json` で管理されています。
*   **関連:** [フロントエンド](#フロントエンド-frontend), [Amazon Cognito](#amazon-cognito), [Amplify Auth](#amplify-auth), [Amplify UI React](#amplify-ui-react-aws-amplifyuireact), [Authenticator Component](#authenticator-component-amplify-ui), [package.json](#packagejson)

**Amplify Auth**
*   **初心者向け解説:** [AWS Amplify](#aws-amplify) ツールキットの中の、「認証」に関する機能を集めた部分です。これを使うと、[Amazon Cognito](#amazon-cognito) と連携して、ユーザー登録、ログイン、ログアウト、ログイン状態の管理などを簡単にプログラムに追加できます。このプロジェクトでは、ログインしているユーザーの情報を取得したり、API を呼び出すために必要な「デジタル身分証明書」([ID Token](#id-token-cognito)) をもらうために使われています。
*   **技術的な解説:**
    *   **定義:** [AWS Amplify](#aws-amplify) ライブラリの認証カテゴリ (`Auth`) です。[Amazon Cognito](#amazon-cognito) と連携し、ユーザーのサインアップ、サインイン、サインアウト、セッション管理などの機能を提供します。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` で `import { Auth } from 'aws-amplify'` され、`Auth.currentSession()` を呼び出して現在のユーザーセッションと [ID Token](#id-token-cognito) を取得するために使用されています。これにより、バックエンド API へのリクエストに必要な認証情報を得ています。
*   **関連:** [AWS Amplify](#aws-amplify), [Amazon Cognito](#amazon-cognito), 認証, セッション管理, [ID Token](#id-token-cognito)

**Amplify UI React (@aws-amplify/ui-react)**
*   **初心者向け解説:** [AWS Amplify](#aws-amplify) が提供する、[React](#react) という技術で作られたウェブサイト向けの「見た目部品ライブラリ」です。特に、ログイン画面 ([Authenticator](#authenticator-component-amplify-ui)) など、AWS のサービスと連携する部品が用意されていて、簡単に見栄えの良い画面を作ることができます。このプロジェクトでは、ログイン画面を素早く実装するために、このライブラリの `Authenticator` 部品を使っています。
*   **技術的な解説:**
    *   **定義:** [AWS Amplify](#aws-amplify) が提供する、[React](#react) アプリケーション向けの UI コンポーネントライブラリです。認証 ([Authenticator](#authenticator-component-amplify-ui) など) や他の AWS サービス連携のためのコンポーネントが含まれます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` で `import { Authenticator } from '@aws-amplify/ui-react'` され、認証 UI を実装するために使用されています。関連する CSS (`@aws-amplify/ui-react/styles.css`) もインポートされ、見た目を整えています。依存関係は `simplechat/frontend/package.json` で管理されています。
*   **関連:** [AWS Amplify](#aws-amplify), [React](#react), UI コンポーネントライブラリ, [Authenticator Component](#authenticator-component-amplify-ui), [package.json](#packagejson)

**axios**
*   **初心者向け解説:** ウェブページ (ブラウザ) が、裏方で動いているサーバーや API と「通信」するための便利な道具 (ライブラリ) です。例えば、チャット画面がバックエンドのチャット機能に「新しいメッセージを送るよ！」とか「応答をちょうだい！」とお願い（HTTP リクエスト）する際に、この axios を使うと簡単に通信のプログラムを書けます。
*   **技術的な解説:**
    *   **定義:** ブラウザと Node.js のための Promise ベースの HTTP クライアントライブラリです。非同期の HTTP リクエストを簡単に行うことができます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` で `import axios from 'axios'` され、`handleSubmit` 関数内でバックエンドの [API Gateway](#amazon-api-gateway) エンドポイント (`config.apiEndpoint`) に POST リクエストを送信するために使用されています。リクエストヘッダーに `Authorization` ([ID Token](#id-token-cognito)) を含めて、認証済みのリクエストを送っています。依存関係は `simplechat/frontend/package.json` で管理されています。
*   **関連:** HTTP クライアント, Promise, API 呼び出し, [フロントエンド](#フロントエンド-frontend), [package.json](#packagejson), [Amazon API Gateway](#amazon-api-gateway)

**AWS CDK (Cloud Development Kit)**
*   **初心者向け解説:** AWS の様々なサービス (部品) を組み合わせてシステムを作る際に、まるでプラモデルの設計図をコード (プログラム) で書くように、インフラ（システムの土台）を構築・管理できるツールです。マウスでポチポチ設定する代わりに、コードで記述するので、間違いが少なく、同じ構成を何度でも正確に再現できます。このプロジェクトでは、Cognito, S3, Lambda, API Gateway などの AWS サービスの設定や連携を、TypeScript という言語で記述し、`cdk deploy` というコマンド一つでまとめて AWS 上に作成・更新しています。
*   **技術的な解説:**
    *   **定義:** AWS のインフラストラクチャを、使い慣れたプログラミング言語 (TypeScript, Python, Java, C#, Go) を使ってコードで定義し、プロビジョニングするためのオープンソースのフレームワークです。
    *   **プロジェクトでの役割:** このプロジェクトでは [TypeScript](#typescript) を使用して、[AWS Lambda](#aws-lambda) 関数、[Amazon API Gateway](#amazon-api-gateway)、[Amazon Cognito](#amazon-cognito) ユーザープール、[Amazon S3](#amazon-s3-simple-storage-service) バケット、[Amazon CloudFront](#amazon-cloudfront) ディストリビューションなどの AWS リソースを `simplechat/lib/bedrock-chatbot-stack.ts` 内で定義・管理しています。`cdk deploy` コマンドで [CloudFormation](#cloudformation) テンプレートが生成され、リソースがデプロイされます。CDK Toolkit (CLI) は `simplechat/package.json` の `devDependencies` で管理され、`scripts` でコマンドエイリアスが定義されています。
*   **関連:** [CloudFormation](#cloudformation), [IaC (Infrastructure as Code)](#iac-infrastructure-as-code), [Construct (CDK)](#construct-cdk), [cdk.json](#cdkjson), [package.json](#packagejson), [TypeScript](#typescript)

**AWS Lambda**
*   **初心者向け解説:** プログラムを動かすための「小さな実行スペース」を、必要な時にだけ借りられるサービスです。サーバー（コンピュータ）を自分で用意したり管理したりする必要がなく、プログラムのコードを置くだけで、何かのイベント（例えば API Gateway へのリクエスト）があった時に自動で実行してくれます。実行された時間分だけ料金がかかるので、効率的です。このプロジェクトでは、チャットの応答を生成するプログラム (`ChatFunction`) や、設定ファイルを作成するプログラム (`ConfigGeneratorFunction`) を Lambda で動かしています。
*   **技術的な解説:**
    *   **定義:** サーバーのプロビジョニングや管理なしにコードを実行できるコンピューティングサービスです (サーバーレス)。
    *   **プロジェクトでの役割:** このプロジェクトでは2つの Lambda 関数が使用されています。
        *   `ChatFunction` (`simplechat/lambda/index.py`): [Python](#python) で書かれ、[API Gateway](#amazon-api-gateway) からのリクエストを受け取ります。リクエストボディからユーザーメッセージと[会話履歴](#conversation-history)を抽出し、[Boto3](#boto3) を使って [Amazon Bedrock](#amazon-bedrock) の `invoke_model` API を呼び出し、チャット応答を生成します。応答と更新された会話履歴を JSON 形式で返します。
        *   `ConfigGeneratorFunction`: [Node.js](#nodejs) で書かれ、CDK デプロイ時に [Custom Resource](#custom-resource-cdk) として実行され、フロントエンド用の設定ファイル (`config.js`) を生成して [S3](#amazon-s3-simple-storage-service) にアップロードし、[CloudFront](#amazon-cloudfront) キャッシュを無効化します。
*   **関連:** [サーバーレス](#サーバーレス-serverless), FaaS (Function as a Service), [Amazon API Gateway](#amazon-api-gateway), [Amazon Bedrock](#amazon-bedrock), [Custom Resource (CDK)](#custom-resource-cdk), [Boto3](#boto3), [Python](#python), [Node.js](#nodejs)

**バックエンド (Backend)**
*   **初心者向け解説:** ウェブサイトやアプリの「舞台裏」や「エンジンルーム」のことです。ユーザーが直接目にすることはないけれど、データの処理、計算、保存、他のサービスとの連携など、アプリケーションの中心的な機能やロジックを担当しています。レストランで言えば、キッチンや食材管理、予約システムなどがバックエンドにあたります。このプロジェクトでは、[AWS Lambda](#aws-lambda) 関数 (`ChatFunction`) が [Amazon Bedrock](#amazon-bedrock) と通信して応答を生成する部分や、[Amazon Cognito](#amazon-cognito) によるユーザー認証などがバックエンドの主要な機能です。
*   **技術的な解説:** ユーザーインターフェース（フロントエンド）からのリクエストを受け取り、ビジネスロジックの実行、データベースとのやり取り、外部 API との連携などを行うサーバーサイドのコンポーネント群。状態の管理やデータの永続化、セキュリティの強制なども担当します。
*   **関連:** [フロントエンド](#フロントエンド-frontend), [サーバー](#サーバー-server), [AWS Lambda](#aws-lambda), [Amazon API Gateway](#amazon-api-gateway), [Amazon Bedrock](#amazon-bedrock), [Amazon Cognito](#amazon-cognito)

**Bedrock Runtime Client (Boto3)**
*   **初心者向け解説:** Python プログラムが [Amazon Bedrock](#amazon-bedrock) の AI 機能（モデル呼び出し）を使うための「専用リモコン」のようなものです。[Boto3](#boto3) という AWS 操作ライブラリの一部で、これを使うと Python コードから簡単に Bedrock に「この文章で応答を生成して！」と指示を送ることができます。
*   **技術的な解説:**
    *   **定義:** [Boto3](#boto3) ライブラリの一部で、[Amazon Bedrock](#amazon-bedrock) のランタイムサービス (モデルの呼び出しなど) と対話するためのクライアントオブジェクトです。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` では、`boto3.client("bedrock-runtime", region_name=region)` によって初期化され、`invoke_model` メソッドを呼び出して Bedrock モデルに推論を実行させるために使用されます。Lambda のグローバルスコープで初期化することで、関数のウォームスタート時にクライアントの再初期化を避け、パフォーマンスを向上させています。
*   **関連:** [Amazon Bedrock](#amazon-bedrock), [Boto3](#boto3), [invoke_model](#invoke_model-bedrock-api), [Python](#python)

**Boto3**
*   **初心者向け解説:** Python というプログラミング言語を使って、AWS の様々なサービス（S3, Lambda, Bedrock など）を操作するための「公式ツールキット（SDK）」です。これを使えば、Python コードから AWS の機能を呼び出したり、設定を変更したりできます。このプロジェクトの Lambda 関数 (`ChatFunction`) では、Bedrock にアクセスするためにこの Boto3 を利用しています。
*   **技術的な解説:**
    *   **定義:** Python 用の AWS SDK (Software Development Kit) です。Python スクリプトから AWS の各種サービス (S3, EC2, DynamoDB, Bedrock など) を操作するための API を提供します。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` で `import boto3` され、[Amazon Bedrock](#amazon-bedrock) サービスと対話するためのクライアント (`bedrock-runtime`) を作成・使用するために利用されています。必要なバージョンは `simplechat/lambda/requirements.txt` で指定されています。
*   **関連:** AWS SDK, [Python](#python), [AWS Lambda](#aws-lambda), [Amazon Bedrock](#amazon-bedrock), [requirements.txt](#requirementstxt)

**browserslist**
*   **初心者向け解説:** 作成するウェブサイトが、どの種類のウェブブラウザ（Chrome, Firefox, Safari など）や、どれくらい古いバージョンのブラウザで正しく表示されるように対応するかの「対応ブラウザリスト」を定義する設定です。開発ツールはこのリストを見て、古いブラウザでも動くように自動でコードを調整してくれます。
*   **技術的な解説:**
    *   **定義:** プロジェクトがサポートするブラウザの範囲を、共有可能な設定で指定するためのツールおよび設定規約です。Autoprefixer, Babel, ESLint などの多くのフロントエンドツールがこの設定を参照します。
    *   **プロジェクトでの役割:** `simplechat/frontend/package.json` 内の `browserslist` キーで設定されています。`production` (本番) 環境と `development` (開発) 環境で異なるターゲットブラウザを指定しています。これにより、ビルドツール (例: [react-scripts](#react-scripts) 内の Babel や Autoprefixer) が生成する JavaScript や CSS を最適化し、必要なポリフィル（古いブラウザ向けの補完機能）やベンダープレフィックス（ブラウザ固有の CSS 設定）を適切に付与します。
*   **関連:** [フロントエンド](#フロントエンド-frontend), ブラウザ互換性, Babel, Autoprefixer, [package.json](#packagejson)

**CDN (Content Delivery Network)**
*   **初心者向け解説:** ウェブサイトのコンテンツ（画像、動画、ファイルなど）を、世界中のユーザーに素早く届けるための「配信網」です。元のサーバー（オリジン）にあるコンテンツのコピーを、世界各地にあるサーバー（エッジサーバー）に配置しておき、ユーザーに一番近いサーバーからコンテンツを配信することで、表示速度を向上させ、元のサーバーへの負荷を減らします。[Amazon CloudFront](#amazon-cloudfront) は CDN サービスの一つです。
*   **技術的な解説:** 地理的に分散されたサーバー群（エッジロケーション）にコンテンツのキャッシュを配置し、ユーザーに最も近いエッジサーバーからコンテンツを配信することで、レイテンシの削減、オリジンサーバーの負荷軽減、可用性の向上を実現するネットワークシステム。
*   **関連:** [Amazon CloudFront](#amazon-cloudfront), キャッシュ, エッジロケーション, パフォーマンス

**CDK App (cdk.App)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) を使ってインフラを定義する際の、「設計図全体」をまとめる入れ物のようなものです。この中に、具体的な部品の設計図 ([Stack](#cdk-stack-cdkstack)) を一つ以上含めます。
*   **技術的な解説:**
    *   **定義:** CDK アプリケーションのルートとなる[コンストラクト](#construct-cdk)です。一つ以上の[スタック](#cdk-stack-cdkstack)を含みます。
    *   **プロジェクトでの役割:** `simplechat/bin/bedrock-chatbot.ts` で `new cdk.App()` としてインスタンス化され、このプロジェクトのインフラ定義である `BedrockChatbotStack` を内包しています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [Construct (CDK)](#construct-cdk), [CDK Stack](#cdk-stack-cdkstack)

**cdk.json**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) ツールが、インフラ設計図 (CDK コード) をどのように読み込んで実行するかを指定するための「設定指示書」ファイルです。どのファイルから実行を開始するか、どのファイルが変更されたら監視するか、といった情報が書かれています。
*   **技術的な解説:**
    *   **定義:** [AWS CDK](#aws-cdk-cloud-development-kit) アプリケーションの設定ファイルです。CDK Toolkit がアプリケーションをどのように実行するか (`app` キー)、どのファイルを監視するか (`watch` キー)、および CDK の機能フラグ (`context` キー) などを定義します。
    *   **プロジェクトでの役割:** `simplechat/cdk.json` では、`app` キーで `ts-node` を使用して TypeScript のエントリーポイント (`bin/bedrock-chatbot.ts`) を実行するように指定されています。また、`context` キーには多数の機能フラグが設定されており、CDK の挙動を制御し、将来のバージョンとの互換性を保つ役割を果たしています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), 設定ファイル, [ts-node](#ts-node), [Feature Flag (CDK)](#feature-flag-cdk)

**CDK Stack (cdk.Stack)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) でインフラを定義する際の、「部品セット」の単位です。関連する AWS サービス（例えば、ウェブサイト公開に必要な S3, CloudFront など）の設定をひとまとめにしたものです。このスタック単位で、AWS 上にリソースを作成したり削除したりします。
*   **技術的な解説:**
    *   **定義:** CDK におけるデプロイの単位であり、関連する AWS リソースの集合です。[CloudFormation](#cloudformation) スタックに相当します。
    *   **プロジェクトでの役割:** `BedrockChatbotStack` クラス (`simplechat/lib/bedrock-chatbot-stack.ts`) がこれに該当し、チャットボットアプリケーションに必要なすべての AWS リソース群 (Cognito, S3, CloudFront, Lambda, API Gateway など) を一つの単位として定義しています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [CloudFormation](#cloudformation), [Construct (CDK)](#construct-cdk), デプロイ単位

**CDK Stack Props (cdk.StackProps)**
*   **初心者向け解説:** [CDK Stack](#cdk-stack-cdkstack) (部品セット) を作る際に、外部から渡すことができる「設定値」や「オプション」のことです。例えば、どの AI モデルを使うか、どの AWS リージョンに作るか、といった情報を Stack 作成時に指定できます。
*   **技術的な解説:**
    *   **定義:** CDK [スタック](#cdk-stack-cdkstack)を初期化する際に渡すことができるプロパティ (設定値) のインターフェースです。
    *   **プロジェクトでの役割:** `BedrockChatbotStack` のコンストラクタの第3引数で渡されるオブジェクトがこれに該当します。`env` (デプロイ先の AWS アカウントとリージョン、ただしコードに型エラーあり) や、このプロジェクト独自の `modelId` (使用する Bedrock モデルの ID) などが含まれます。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [CDK Stack](#cdk-stack-cdkstack), 設定, パラメータ

**CloudFormation**
*   **初心者向け解説:** AWS のサービスを使ってシステム（インフラ）を構築する際に、その構成（どのサービスをどう設定するか）を「設計図ファイル」（テンプレート）に記述しておき、その設計図通りに自動で AWS 上にリソースを作成・管理してくれるサービスです。[AWS CDK](#aws-cdk-cloud-development-kit) は、プログラミング言語で書かれたコードを、最終的にこの CloudFormation が理解できる設計図ファイルに変換して、インフラ構築を行っています。CDK の裏側で働いている縁の下の力持ちです。
*   **技術的な解説:**
    *   **定義:** AWS リソースのモデル化とセットアップを支援するサービスです。テンプレートファイル (JSON または YAML) を使用して、関連する AWS リソースのコレクション (スタック) を作成および管理します。
    *   **プロジェクトでの役割:** [AWS CDK](#aws-cdk-cloud-development-kit) は、開発者が記述した TypeScript コードを `cdk synth` コマンドで CloudFormation テンプレートに変換（合成）します。そして `cdk deploy` コマンドを実行すると、CDK はこのテンプレートを CloudFormation サービスに渡し、CloudFormation がテンプレートに基づいて AWS リソースをプロビジョニング（作成・更新）します。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [IaC (Infrastructure as Code)](#iac-infrastructure-as-code), スタック, テンプレート

**CloudFront Distribution**
*   **初心者向け解説:** [Amazon CloudFront](#amazon-cloudfront) (高速配達ネットワーク) を使うための具体的な「設定プラン」のことです。どの倉庫 ([S3](#amazon-s3-simple-storage-service) バケットなど) からデータを取ってくるか、どのウェブサイトアドレス (ドメイン名) でアクセスできるようにするか、どのようにデータを一時保管 (キャッシュ) するか、などの詳細なルールを定義します。
*   **技術的な解説:**
    *   **定義:** [Amazon CloudFront](#amazon-cloudfront) の中核となる設定で、コンテンツをどのように配信するか (どのオリジンから、どのキャッシュ設定で、どのドメイン名でなど) を定義します。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` で `new cloudfront.Distribution(...)` として作成され、[S3](#amazon-s3-simple-storage-service) バケット (`WebsiteBucket`) を[オリジン](#cloudfront-origin)として設定し、HTTPS へのリダイレクト、SPA (Single Page Application) 対応のためのカスタムエラーページ設定、キャッシュ動作などを定義しています。
*   **関連:** [Amazon CloudFront](#amazon-cloudfront), [CDN](#cdn-content-delivery-network), [CloudFront Origin](#cloudfront-origin), キャッシュ設定

**CloudFront Origin**
*   **初心者向け解説:** [CloudFront](#amazon-cloudfront) (高速配達ネットワーク) が、配信するデータ（ウェブサイトのファイルなど）を元々取得してくる「供給元」のことです。このプロジェクトでは、フロントエンドのウェブページファイルが保管されている [Amazon S3](#amazon-s3-simple-storage-service) の倉庫 (バケット) が、CloudFront のオリジンとして設定されています。
*   **技術的な解説:**
    *   **定義:** [CloudFront](#amazon-cloudfront) がコンテンツを取得する元の場所です。S3 バケット、EC2 インスタンス、ELB、任意の HTTP サーバーなどが指定できます。
    *   **プロジェクトでの役割:** このプロジェクトでは、`origins.S3Origin(websiteBucket)` として、フロントエンドの静的ファイルが格納されている [S3](#amazon-s3-simple-storage-service) バケット (`WebsiteBucket`) がオリジンとして指定されています。CloudFront はユーザーからのリクエストに応じて、この S3 バケットからコンテンツを取得し、キャッシュしてユーザーに配信します。
*   **関連:** [Amazon CloudFront](#amazon-cloudfront), [CDN](#cdn-content-delivery-network), [Amazon S3](#amazon-s3-simple-storage-service), [CloudFront Distribution](#cloudfront-distribution)

**CloudWatch Logs**
*   **初心者向け解説:** AWS 上で動いているプログラムやサービスが、動作中にどのような処理を行ったか、エラーが発生しなかったかなどの「活動記録」（ログ）を自動的に集めて保管・閲覧できるサービスです。何か問題が起きたときに、原因を調査するための重要な手がかりになります。このプロジェクトでは、Lambda 関数 (`ChatFunction` など) の実行ログや、API Gateway のアクセスログなどがここに記録されます。
*   **技術的な解説:**
    *   **定義:** AWS リソース、アプリケーション、およびカスタムログファイルのログをモニタリング、保存、アクセスするためのサービスです。
    *   **プロジェクトでの役割:** [AWS Lambda](#aws-lambda) 関数 (`ChatFunction`, `ConfigGeneratorFunction`) や [API Gateway](#amazon-api-gateway) などのログは自動的に CloudWatch Logs に送信されます。`simplechat/lambda/index.py` 内の `print()` 文の出力もここに記録されるため、Lambda 関数の実行状況の確認や、エラー発生時のデバッグ、運用監視に不可欠です。
*   **関連:** [AWS Lambda](#aws-lambda), ロギング, デバッグ, モニタリング

**Component (React)**
*   **初心者向け解説:** [React](#react) という技術を使ってウェブページを作る際の、「再利用可能な UI 部品」のことです。例えば、ボタン、入力フォーム、ヘッダー、チャットのメッセージ表示部分などをそれぞれ部品として作り、それらを組み合わせることでページ全体を構築します。同じ部品を色々な場所で使い回せるので、効率的に開発できます。このプロジェクトでは、チャット画面全体 (`ChatInterface`) や、それを表示する枠組み (`App`) がコンポーネントとして作られています。
*   **技術的な解説:**
    *   **定義:** [React](#react) アプリケーションの UI を構成する独立した再利用可能な部品です。JavaScript の関数またはクラスとして定義され、[Props](#props-react) を受け取り、画面に表示する要素 ([JSX](#jsx-javascript-xml)) を返します。コンポーネントは自身の状態 ([State](#state-react)) を持つこともできます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` では、`ChatInterface` と `App` という2つの関数コンポーネントが定義されています。`App` コンポーネントは認証状態に応じて `ChatInterface` コンポーネントをレンダリングします。これらのコンポーネントが組み合わさってチャットアプリケーションの UI を形成しています。
*   **関連:** [React](#react), [JSX](#jsx-javascript-xml), [Props (React)](#props-react), [State (React)](#state-react), UI

**config.js (Frontend)**
*   **初心者向け解説:** フロントエンドのチャット画面 ([React](#react) アプリ) が、動作するために必要な「設定情報」が書かれたファイルです。例えば、通信相手のバックエンド API の住所 (URL) や、ユーザー認証サービス (Cognito) の ID など、環境によって変わる可能性のある情報が含まれています。このファイルは、システムを AWS にデプロイする際に、CDK によって自動生成され、S3 に置かれます。
*   **技術的な解説:**
    *   **定義:** このプロジェクトにおいて、フロントエンドアプリケーション ([React](#react)) が実行時に必要とする設定情報 (API エンドポイント URL、Cognito ユーザープール ID、クライアント ID、リージョンなど) を格納するために動的に生成される JavaScript ファイルです。
    *   **プロジェクトでの役割:** このファイルは、[AWS CDK](#aws-cdk-cloud-development-kit) のデプロイプロセス中に `ConfigGeneratorFunction` [Lambda](#aws-lambda) によって生成され、[S3](#amazon-s3-simple-storage-service) バケット (`WebsiteBucket`) のルートに配置されます。フロントエンドの `index.html` 内で `<script src="/config.js"></script>` のように読み込まれ、グローバルな `window.REACT_APP_CONFIG` オブジェクトに設定値を格納します。`simplechat/frontend/src/App.js` の `loadConfig` 関数がこのオブジェクトを参照し、Amplify の設定や API 呼び出し先の URL を決定します。
*   **関連:** [フロントエンド](#フロントエンド-frontend), 設定管理, [AWS CDK](#aws-cdk-cloud-development-kit), [Custom Resource (CDK)](#custom-resource-cdk), [AWS Lambda](#aws-lambda), [Amazon S3](#amazon-s3-simple-storage-service)

**Construct (CDK)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) でインフラをコードで定義する際の、「構成要素」や「部品」を表す基本単位です。S3 バケットのような単一の AWS リソースを表す小さな部品から、複数のリソースを組み合わせて特定の機能を実現する大きな部品（例えば、このプロジェクト全体の `BedrockChatbotStack`）まで、様々なレベルの部品があります。これらの部品を組み合わせてインフラ全体を構築します。
*   **技術的な解説:**
    *   **定義:** [AWS CDK](#aws-cdk-cloud-development-kit) における基本的な構成要素です。単一の AWS リソース (例: S3 バケット) から、複数のリソースを組み合わせた抽象的なコンポーネント (例: このプロジェクトの `BedrockChatbotStack`) まで、あらゆるものを表します。Construct は階層的に構成され、他の Construct を含むことができます。
    *   **プロジェクトでの役割:** `BedrockChatbotStack` クラス自身も Construct であり、その内部で `cognito.UserPool`, `s3.Bucket`, `lambda.Function` など、他の多くの Construct (L1, L2, または L3 Construct) をインスタンス化して AWS リソースを定義しています。`Construct` クラスは `constructs` ライブラリからインポートされ、`simplechat/package.json` の `dependencies` に含まれています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), 抽象化, 構成, [CDK Stack](#cdk-stack-cdkstack)

**Conversation History**
*   **初心者向け解説:** チャットボットとの会話における、「それまでのやり取りの記録」のことです。人間同士の会話でも、前の発言を踏まえて次の話をするように、AI チャットボットも過去の会話の流れ（文脈）を理解することで、より自然で的確な応答ができるようになります。このプロジェクトでは、ユーザーがメッセージを送るたびに、それまでの会話履歴も一緒にバックエンドに送り、AI (Bedrock) が文脈を考慮した応答を生成できるようにしています。
*   **技術的な解説:**
    *   **定義:** チャットボットとの対話において、それまでのユーザーとアシスタントの発言の履歴です。文脈を維持し、より自然で関連性の高い応答を生成するために LLM に入力として渡されます。通常、各発言に話者 (例: "user", "assistant") と内容が含まれるリスト形式で表現されます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` では `messages` という [State](#state-react) 変数で管理され、ユーザーの入力とアシスタントの応答が `{ role: 'user' | 'assistant', content: '...' }` の形式で追加されていきます。この履歴はバックエンド API 呼び出し時にペイロード (`conversationHistory`) として送信されます。バックエンド (`simplechat/lambda/index.py`) はこれを受け取り、[Bedrock](#amazon-bedrock) API が要求する形式に変換して渡し、応答を受け取った後に更新された履歴 (アシスタントの応答を含む) をフロントエンドに返します。
*   **関連:** [LLM (大規模言語モデル)](#llm-large-language-model), コンテキストウィンドウ, 状態管理, [React State](#state-react)

**CORS (Cross-Origin Resource Sharing)**
*   **初心者向け解説:** ウェブブラウザの安全機能の一つで、通常は「違うドメイン（ウェブサイトのアドレス）からのデータや機能の呼び出しを制限する」というルールがあります。しかし、現代のウェブアプリでは、違うドメインにある API などを呼び出す必要がよくあります。CORS は、サーバー側が「このドメインからのアクセスは許可しますよ」と設定することで、この制限を安全に緩和するための仕組みです。このプロジェクトでは、CloudFront で表示されるチャット画面 (あるドメイン) が、API Gateway (別のドメイン) にあるチャット API を呼び出せるように、API Gateway や S3 で CORS の設定を行っています。
*   **技術的な解説:**
    *   **定義:** ウェブブラウザが、あるオリジン (ドメイン、プロトコル、ポートの組み合わせ) で動作しているウェブアプリケーションに、異なるオリジンにあるリソースへのアクセスを許可するための仕組みです。サーバーが特定の HTTP ヘッダー (`Access-Control-Allow-Origin` など) を返すことで、ブラウザにクロスオリジンリクエストを許可するよう指示します。複雑なリクエスト (POST など) の前には、ブラウザが OPTIONS メソッドで「Preflight リクエスト」を送信し、サーバーに許可を確認することがあります。
    *   **プロジェクトでの役割:** このプロジェクトでは、[API Gateway](#amazon-api-gateway) の設定 (`defaultCorsPreflightOptions`) で、特定のオリジン (デプロイされた CloudFront の URL など、ただし現状は `AllowAnyOrigin` かもしれない) からのアクセスと特定のヘッダー (`Authorization` など) を許可するように設定されています。また、[S3](#amazon-s3-simple-storage-service) バケットにも CORS 設定 (`cors`) が施されています。さらに、[AWS Lambda](#aws-lambda) (`ChatFunction`) のレスポンスヘッダーにも `Access-Control-Allow-*` が含まれており、ブラウザがフロントエンドから API Gateway へのリクエストをブロックしないようにしています。
*   **関連:** HTTP ヘッダー, Preflight リクエスト (OPTIONS), セキュリティ, オリジン, [Amazon API Gateway](#amazon-api-gateway), [Amazon S3](#amazon-s3-simple-storage-service), [AWS Lambda](#aws-lambda)

**Create React App (CRA)**
*   **初心者向け解説:** [React](#react) を使ったウェブアプリ開発を始める際に、必要な設定やツール（開発用サーバー、ビルドツールなど）をまとめて提供してくれる「スターターキット」です。これを使うと、開発者は複雑な初期設定に悩むことなく、すぐに React のコードを書き始めることができます。このプロジェクトのフロントエンド部分は、おそらくこの CRA を使って初期構築されたと考えられます。
*   **技術的な解説:**
    *   **定義:** [React](#react) アプリケーションをセットアップするための公式にサポートされている方法の一つです。複雑なビルド設定 (Webpack, Babel など) を抽象化し、すぐに開発を開始できる環境を提供します。`react-scripts` というパッケージに主要な機能が含まれています。
    *   **プロジェクトでの役割:** `simplechat/frontend/` ディレクトリは Create React App を使用して作成された可能性が高いです。その証拠として、`dependencies` に [`react-scripts`](#react-scripts-react-scripts) が含まれており、`package.json` の `scripts` に `start`, `build`, `test`, `eject` が定義されています。`eslintConfig` や `browserslist` の設定も CRA の標準的な構成に従っています。
*   **関連:** [React](#react), [フロントエンド](#フロントエンド-frontend), ビルドツール, [react-scripts](#react-scripts-react-scripts), [package.json](#packagejson)

**Custom Resource (CDK)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) でインフラを構築する際に、CDK や CloudFormation が標準で持っていない「特別な作業」を実行させるための仕組みです。例えば、「デプロイ時に特定のファイルを生成して S3 に置く」といったカスタムな処理を、Lambda 関数を使って実現できます。このプロジェクトでは、フロントエンド用の設定ファイル (`config.js`) を自動生成して S3 にアップロードし、CloudFront のキャッシュを更新するという特別な作業を、この仕組みを使って行っています。
*   **技術的な解説:**
    *   **定義:** [CloudFormation](#cloudformation) がネイティブでサポートしていないカスタムのプロビジョニングロジックを [AWS CDK](#aws-cdk-cloud-development-kit) スタックのデプロイメント中に実行するための仕組みです。通常、[AWS Lambda](#aws-lambda) 関数を「サービスプロバイダー」として実装し、CloudFormation がデプロイライフサイクル (Create, Update, Delete) に応じて Lambda を呼び出します。Lambda は処理結果を CloudFormation に通知する必要があります。
    *   **プロジェクトでの役割:** このプロジェクトでは、`ConfigGeneratorFunction` という Lambda 関数をハンドラーとするカスタムリソース (`ConfigResource`) が定義されています。これは、CDK (CloudFormation) のデプロイプロセス中に、フロントエンド用の設定ファイル (`config.js`) を動的に生成（API エンドポイントや Cognito ID を埋め込む）して [S3](#amazon-s3-simple-storage-service) バケットにアップロードし、`index.html` を修正してこのファイルを読み込ませ、最後に [CloudFront](#amazon-cloudfront) キャッシュを無効化するために使用されます。`aws-cdk-lib/custom-resources` モジュールと `cr.Provider` (Custom Resource Provider Framework) を使用して実装されています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [AWS Lambda](#aws-lambda), [CloudFormation](#cloudformation), 自動化, プロビジョニング

**dependencies (package.json)**
*   **初心者向け解説:** [Node.js](#nodejs) プロジェクト（CDK や React アプリなど）が、実際に「動作するために必要」な外部のプログラム部品（パッケージ、ライブラリ）のリストです。[package.json](#packagejson) という設定ファイルに書かれています。`npm install` というコマンドを実行すると、ここにリストされた部品がインターネットからダウンロード・準備されます。
*   **技術的な解説:**
    *   **定義:** [`package.json`](#packagejson) ファイル内で、アプリケーションが**実行時**に必要とする [npm](#npm-node-package-manager) パッケージとそのバージョンを指定するセクションです。`npm install` コマンドでインストールされ、通常、本番環境にも含まれます。
    *   **プロジェクトでの役割:**
        *   ルート (`simplechat/package.json`): [AWS CDK](#aws-cdk-cloud-development-kit) アプリケーションの実行に必要な `aws-cdk-lib`, `constructs`, `source-map-support` がリストされています。これらは CDK コードを実行して CloudFormation テンプレートを生成するために必要です。
        *   フロントエンド (`simplechat/frontend/package.json`): [React](#react) アプリケーションがブラウザで動作するために必要な `@aws-amplify/ui-react`, `aws-amplify`, [`axios`](#axios), `react`, `react-dom`, [`react-scripts`](#react-scripts-react-scripts), `web-vitals` などがリストされています。
*   **関連:** [package.json](#packagejson), [npm](#npm-node-package-manager), [devDependencies (package.json)](#devdependencies-packagejson), 依存関係管理

**devDependencies (package.json)**
*   **初心者向け解説:** [Node.js](#nodejs) プロジェクトの開発やビルド（完成品を作ること）の「作業中にだけ必要」な道具（パッケージ、ツール）のリストです。例えば、コードのチェックツール、テストツール、TypeScript を JavaScript に変換するツールなどがここに含まれます。これらは実際にアプリが動くときには不要なので、本番環境には通常含まれません。[package.json](#packagejson) に書かれています。
*   **技術的な解説:**
    *   **定義:** [`package.json`](#packagejson) ファイル内で、アプリケーションの**開発やビルド**時にのみ必要となる [npm](#npm-node-package-manager) パッケージとそのバージョンを指定するセクションです。`npm install` コマンドでインストールされますが、本番環境へのデプロイ時には通常含まれません（`npm install --production` などで除外可能）。
    *   **プロジェクトでの役割:** `simplechat/package.json` の `devDependencies` には、TypeScript の型定義 (`@types/*`)、テストフレームワーク ([`jest`](#jest), `ts-jest`)、TypeScript コンパイラ ([`typescript`](#typescript), [`tsc`](#tsc)), CDK Toolkit (`aws-cdk` CLI), TypeScript 実行エンジン ([`ts-node`](#ts-node)) などが含まれています。これらは CDK コードを開発、テスト、デプロイするために必要ですが、CDK が生成した CloudFormation テンプレートを実行する AWS 環境には不要です。フロントエンドの `package.json` には明示的な `devDependencies` がありませんが、これは [Create React App](#create-react-app-cra) ([`react-scripts`](#react-scripts-react-scripts)) がテストやビルドに必要なツールを内部の依存関係として管理しているためです。
*   **関連:** [package.json](#packagejson), [npm](#npm-node-package-manager), [dependencies (package.json)](#dependencies-packagejson), 開発環境, ビルドプロセス

**DOM (Document Object Model)**
*   **初心者向け解説:** ウェブページ（HTML）の構造（見出し、段落、画像、ボタンなど）を、プログラム（特に JavaScript）が理解し、操作できるようにするための「設計図」や「マップ」のようなものです。JavaScript はこの DOM を通じて、「このボタンがクリックされたら色を変える」とか「ここに新しいメッセージを追加する」といった操作を行います。React はこの DOM 操作を効率的に行うためのライブラリです。
*   **技術的な解説:**
    *   **定義:** HTML や XML ドキュメントのためのプログラミングインターフェースです。ドキュメントの構造化された表現 (ツリー構造) を提供し、プログラム (例: JavaScript) がドキュメントの内容、構造、スタイルを動的に読み取ったり変更したりできるようにします。ブラウザが HTML を解析して DOM ツリーを構築します。
    *   **プロジェクトでの役割:** [React](#react) は仮想 DOM (Virtual DOM) を使用してパフォーマンスを最適化しますが、最終的にはブラウザの実際の DOM を操作して UI を更新します。`simplechat/frontend/src/index.js` の `document.getElementById('root')` は、ブラウザの DOM API を直接使用して、React アプリを挿入する HTML 要素を取得しています。また、`simplechat/frontend/src/App.js` で [useRef](#ref-hook-useref) フックがチャットメッセージリストの末尾要素への参照を取得し、`.scrollIntoView()` メソッドを呼び出すことで、DOM 要素を直接操作してスクロールを実現しています。
*   **関連:** HTML, ウェブブラウザ, JavaScript, [React](#react), 仮想 DOM, [useRef](#ref-hook-useref)

**Effect Hook (useEffect)**
*   **初心者向け解説:** [React](#react) の関数型コンポーネント（UI 部品）の中で、「特定のタイミングで何か特別な処理（副作用）を行いたい」ときに使う機能（フック）です。例えば、「コンポーネントが画面に表示された直後にデータを読み込む」とか、「チャットメッセージが更新されたら一番下までスクロールする」といった、UI の描画以外の処理を実行するために使います。
*   **技術的な解説:**
    *   **定義:** [React](#react) の[フック](#react-hooks)の一つで、関数[コンポーネント](#component-react)内で副作用 (データ取得、購読、DOM の手動変更など) を実行することを可能にします。コンポーネントのレンダリング後や、特定の [State](#state-react) や [Props](#props-react) が変更された後（依存配列で指定）に実行されます。クリーンアップ関数を返すことで、コンポーネントがアンマウントされる際や、エフェクトが再実行される前に後処理を行うこともできます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` の `ChatInterface` コンポーネントで、`messages` ステートが更新されたときにチャットウィンドウを自動スクロールするために `useEffect` が使用されています (`useEffect(() => { scrollToBottom(); }, [messages]);`)。依存配列 `[messages]` が指定されているため、`messages` が変更されるたびに `scrollToBottom()` 関数が実行されます。
*   **関連:** [React](#react), [React Hooks](#react-hooks), 副作用, コンポーネントライフサイクル, [State (React)](#state-react), [Props (React)](#props-react)

**Environment Variables (環境変数)**
*   **初心者向け解説:** プログラムを実行する「環境」（例えば、開発中の自分の PC や、本番の AWS サーバー）ごとに異なる設定値を、プログラムの外から渡すための仕組みです。例えば、開発中はテスト用の API アドレス、本番環境では本物の API アドレスを使う、といった場合に便利です。プログラム内で直接値を書き換える必要がなくなります。
*   **技術的な解説:**
    *   **定義:** オペレーティングシステムや実行環境からプロセス（プログラム）に渡される、名前と値のペアで構成される動的な設定値です。
    *   **プロジェクトでの役割:**
        *   **バックエンド (CDK/Lambda):** `simplechat/bin/bedrock-chatbot.ts` では `process.env.CDK_DEFAULT_ACCOUNT` や `process.env.CDK_DEFAULT_REGION` を参照して、CDK のデプロイ対象アカウント・リージョンを取得しています。`ChatFunction` Lambda (`simplechat/lambda/index.py`) は、使用する Bedrock モデルの ID を環境変数 `MODEL_ID` から `os.environ.get()` で読み取っています (この `MODEL_ID` は CDK スタック定義で設定されます)。`ConfigGeneratorFunction` Lambda には、ソースマップサポートを有効にするための `NODE_OPTIONS` が環境変数として渡されます。
        *   **フロントエンド (React):** ローカル開発時には、`.env` ファイルなどに `REACT_APP_` プレフィックス付きで定義された環境変数が、ビルドプロセスを通じて `process.env` オブジェクトに埋め込まれ、`simplechat/frontend/src/App.js` の `loadConfig` 関数で参照される可能性があります (例: `process.env.REACT_APP_API_ENDPOINT`)。ただし、このプロジェクトではデプロイ環境においては、CDK が生成する [`config.js`](#configjs-frontend) ファイルの値が優先的に使用される設計になっています。
*   **関連:** 設定管理, [AWS CDK](#aws-cdk-cloud-development-kit), [AWS Lambda](#aws-lambda), [React](#react), [config.js (Frontend)](#configjs-frontend)

**ESLint**
*   **初心者向け解説:** JavaScript や関連コード (JSX など) の書き方に間違いがないか、チームで決めたコーディングルール（書き方の作法）に沿っているかを自動でチェックしてくれる「コードの校正ツール」です。バグの早期発見や、コードの読みやすさ・統一感を保つのに役立ちます。
*   **技術的な解説:**
    *   **定義:** JavaScript および JSX コード内の問題（潜在的なバグ、スタイル違反、非推奨な書き方など）を発見し、一部は自動修正も可能な静的コード解析ツール（リンター）です。設定ファイル（例: `.eslintrc.js`, `package.json` の `eslintConfig`）に基づいてルールを適用します。
    *   **プロジェクトでの役割:** `simplechat/frontend/package.json` の `eslintConfig` セクションで設定が定義されており、[Create React App](#create-react-app-cra) の推奨ルールセット (`react-app`, `react-app/jest`) を拡張して使用しています。開発中にエディタ (VS Code など) の拡張機能や、ビルドプロセス (`react-scripts build`) の一部として自動的に実行され、問題があれば警告やエラーを表示します。
*   **関連:** 静的コード解析, リンティング, JavaScript, [React](#react), コード品質, [package.json](#packagejson)

**Event Handling (React)**
*   **初心者向け解説:** [React](#react) で作られたウェブページ上で、ユーザーが何か操作（ボタンをクリックする、文字を入力する、フォームを送信する など）をしたときに、特定の処理（プログラム）を実行させる仕組みのことです。「もしこのボタンがクリックされたら (イベント)、この関数を実行する (ハンドラー)」のように設定します。
*   **技術的な解説:**
    *   **定義:** [React](#react) において、ユーザーのアクション (クリック、入力、フォーム送信など) に応答して特定の JavaScript 関数（イベントハンドラー）を実行する仕組みです。JSX 要素に `onClick`, `onChange`, `onSubmit` などのキャメルケースのイベントハンドラー属性を記述し、対応する関数を `{}` で囲んで指定します。React は内部でイベント委譲などの最適化を行っています。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` では、`ChatInterface` コンポーネント内で複数のイベントハンドリングが行われています。
        *   フォーム送信: `<form onSubmit={handleSubmit}>` で、送信ボタンクリック時や Enter キー押下時に `handleSubmit` 関数が実行されます。
        *   テキストエリア入力: `<textarea onChange={(e) => setInput(e.target.value)}>` で、入力内容が変わるたびに `input` ステートが更新されます。
        *   キー入力: `<textarea onKeyDown={...}>` で、Enter キーが押された場合に (Shift キーなしなら) `handleSubmit` を実行するロジックが実装されています。
        *   ボタンクリック: `<button onClick={clearConversation}>` や `<button onClick={signOut}>` で、それぞれのボタンがクリックされたときに指定の関数が実行されます。
*   **関連:** [React](#react), ユーザーインターフェース, DOM イベント, 関数

**Feature Flag (CDK)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) の新しい機能や、将来変更される可能性のある挙動を、使うかどうかを「オン/オフ」で切り替えられるスイッチのような設定です。これを使うことで、CDK のバージョンアップによる予期せぬ影響を防いだり、新しい機能を試したりすることができます。[cdk.json](#cdkjson) ファイルで設定します。
*   **技術的な解説:**
    *   **定義:** [AWS CDK](#aws-cdk-cloud-development-kit) の特定の機能や挙動を有効化/無効化するための設定です。CDK のバージョンアップに伴う破壊的変更への段階的な移行パスを提供したり、新しい機能のオプトイン/オプトアウトを可能にしたりする目的で使用されます。通常、`@aws-cdk/aws-service:featureFlagName` のような形式で `cdk.json` の `context` に設定されます。
    *   **プロジェクトでの役割:** [`cdk.json`](#cdkjson) ファイルの `context` キー以下に多数の Feature Flag が設定されています（例: `@aws-cdk/aws-ecr-assets:dockerIgnoreSupport`）。これにより、プロジェクトが依存している CDK のバージョンにおいて推奨される挙動や、将来のバージョンとの互換性を考慮した設定が適用されています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [cdk.json](#cdkjson), 設定管理, 互換性, バージョン管理

**フロントエンド (Frontend)**
*   **初心者向け解説:** ウェブサイトやアプリの「表舞台」、つまりユーザーが直接目に触れて操作する部分のことです。ボタン、テキスト、画像、入力フォームなど、画面に表示されるすべての要素とそのデザイン、操作への反応などを担当します。レストランで言えば、客席やメニュー、ウェイターなどがフロントエンドにあたります。このプロジェクトでは、[React](#react) を使って作られたチャット画面 (`simplechat/frontend/` ディレクトリ内のコード) がフロントエンドです。ユーザーはここでメッセージを入力し、応答を見ます。
*   **技術的な解説:** アプリケーションにおいて、ユーザーが直接対話するインターフェース部分。通常、ウェブブラウザ上で HTML, CSS, JavaScript (および React, Vue, Angular などのフレームワーク/ライブラリ) を用いて構築されます。バックエンド API と通信してデータを取得・表示・送信します。
*   **関連:** [バックエンド](#バックエンド-backend), [ユーザーインターフェース (UI)](#component-react), [React](#react), HTML, CSS, JavaScript, [Amazon S3](#amazon-s3-simple-storage-service), [Amazon CloudFront](#amazon-cloudfront)

**IAM (Identity and Access Management)**
*   **初心者向け解説:** AWS の各種サービスを使う際の「権限管理」を行うサービスです。誰（ユーザーやプログラム）が、どの AWS サービス（S3, Lambda など）の、どの操作（読み取り、書き込み、削除など）を行えるかを細かく設定できます。これにより、不正なアクセスや操作を防ぎ、セキュリティを確保します。このプロジェクトでは、Lambda 関数が Bedrock や S3 にアクセスするために必要な最小限の権限を IAM で設定しています。
*   **技術的な解説:**
    *   **定義:** AWS リソースへのアクセスを安全に管理するためのウェブサービスです。ユーザー、グループ、[IAM Role](#iam-role) を作成および管理し、[IAM Policy](#iam-policy-statement) を使用して AWS リソースへのアクセス許可 (Allow) および拒否 (Deny) を定義します。最小権限の原則に従ったアクセス制御を実現します。
    *   **プロジェクトでの役割:** このプロジェクトでは、[AWS CDK](#aws-cdk-cloud-development-kit) を通じて、[AWS Lambda](#aws-lambda) 関数 (`ChatLambdaRole`, `ConfigGeneratorRole`) が他の AWS サービス ([Bedrock](#amazon-bedrock), [S3](#amazon-s3-simple-storage-service), [CloudFront](#amazon-cloudfront)) にアクセスするために必要な権限を定義する [IAM Role](#iam-role) と [IAM Policy Statement](#iam-policy-statement) を作成しています。これにより、各 Lambda 関数は自身のタスクに必要な権限だけを持つことになります。
*   **関連:** [IAM Role](#iam-role), [IAM Policy Statement](#iam-policy-statement), [IAM Managed Policy](#iam-managed-policy), [IAM Service Principal](#iam-service-principal), 認証, 認可, セキュリティ

**IAM Managed Policy**
*   **初心者向け解説:** AWS があらかじめ用意してくれている「権限設定のテンプレート」です。よく使われる権限の組み合わせ（例えば、Lambda がログを書き込むための基本的な権限）がセットになっているので、自分で細かく設定する手間が省けます。
*   **技術的な解説:**
    *   **定義:** AWS によって作成および管理されるスタンドアロンの [IAM](#iam-identity-and-access-management) ポリシーです。一般的なユースケースに対応する権限を提供します (例: `AWSLambdaBasicExecutionRole`, `AmazonS3ReadOnlyAccess`)。ユーザーはこれを IAM プリンシパル (ユーザー、グループ、ロール) にアタッチして使用します。AWS が内容を更新することがあります。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` では、Lambda 関数の基本的な実行権限 (CloudWatch Logs への書き込み権限など) を提供するために、`AWSLambdaBasicExecutionRole` という AWS 管理ポリシーが `ChatLambdaRole` と `ConfigGeneratorRole` という [IAM Role](#iam-role) にアタッチされています。
*   **関連:** [IAM](#iam-identity-and-access-management), [IAM Policy Statement](#iam-policy-statement), [IAM Role](#iam-role)

**IAM Policy Statement**
*   **初心者向け解説:** IAM (権限管理) における、「具体的な権限ルール」の一つ一つを記述したものです。「誰が(これはRoleに紐づく)」「どのサービス(Resource)の」「どの操作(Action)を」「許可するか(Effect: Allow) / 拒否するか(Effect: Deny)」を明確に定義します。これを複数組み合わせることで、詳細なアクセス制御を行います。
*   **技術的な解説:**
    *   **定義:** [IAM](#iam-identity-and-access-management) ポリシー内の個々の権限定義の単位です。通常、`Effect` (Allow/Deny)、`Action` (許可/拒否する API アクション、例: `s3:GetObject`), `Resource` (対象となる AWS リソースの ARN), `Principal` (信頼ポリシーの場合), `Condition` (特定の条件下でのみ許可/拒否) などの要素で構成されます。
    *   **プロジェクトでの役割:** Lambda 実行ロール (`ChatLambdaRole`, `ConfigGeneratorRole`) に、AWS 管理ポリシーだけでは不足する特定の権限 (Bedrock のモデル呼び出し権限 `bedrock:InvokeModel`、S3 へのファイル書き込み権限 `s3:PutObject`、CloudFront キャッシュ無効化権限 `cloudfront:CreateInvalidation` など) を追加するために、`new iam.PolicyStatement({...})` を使用して具体的な権限ルールがインラインで定義され、ロールにアタッチされています。
*   **関連:** [IAM](#iam-identity-and-access-management), [IAM Managed Policy](#iam-managed-policy), [IAM Role](#iam-role), 権限, 認可

**IAM Role**
*   **初心者向け解説:** AWS のサービス（例えば Lambda 関数）やアプリケーションが、一時的に他の AWS サービスにアクセスするための「役割」とそれに紐づく「権限セット」です。人間のユーザーとは違い、プログラムが特定のタスクを実行するために必要な権限を安全に委任する仕組みです。例えば、「Lambda 関数に Bedrock へのアクセス権限を与える役割」といった形で定義します。
*   **技術的な解説:**
    *   **定義:** 特定のアクセス許可を持つ [IAM](#iam-identity-and-access-management) アイデンティティです。IAM ユーザーやグループとは異なり、特定の AWS サービスやアプリケーション、他の AWS アカウントのユーザーなどが一時的に引き受けて (assume) その権限を使用することを目的としています。信頼ポリシーによって、どのプリンシパルがこのロールを引き受けられるかを定義します。
    *   **プロジェクトでの役割:** このプロジェクトでは、`ChatLambdaRole` と `ConfigGeneratorRole` という2つの IAM ロールが作成されています。`ChatLambdaRole` は `ChatFunction` Lambda に割り当てられ、Bedrock へのアクセス権限などを持ちます。`ConfigGeneratorRole` は `ConfigGeneratorFunction` Lambda に割り当てられ、S3 への書き込みや CloudFront キャッシュ無効化の権限などを持ちます。これにより、各 Lambda 関数は自身のタスク遂行に必要な最小限の権限で動作できます。
*   **関連:** [IAM](#iam-identity-and-access-management), [IAM Policy Statement](#iam-policy-statement), [IAM Managed Policy](#iam-managed-policy), [IAM Service Principal](#iam-service-principal), 権限委任, セキュリティ

**IAM Service Principal**
*   **初心者向け解説:** IAM Role (役割と権限セット) を、「どの AWS サービスが使うことができるか」を指定するための識別子です。例えば、「この役割は Lambda 関数が使っていいですよ」と許可を与える際に、`lambda.amazonaws.com` というサービスプリンシパルを指定します。
*   **技術的な解説:**
    *   **定義:** AWS サービスを表す [IAM](#iam-identity-and-access-management) プリンシパルです。[IAM Role](#iam-role) の信頼ポリシー (Trust Policy) で使用され、どの AWS サービスがそのロールを引き受ける (AssumeRole) ことができるかを指定します。形式は通常 `service-name.amazonaws.com` (例: `lambda.amazonaws.com`, `ec2.amazonaws.com`)。
    *   **プロジェクトでの役割:** `new iam.ServicePrincipal('lambda.amazonaws.com')` は、作成される IAM Role (`ChatLambdaRole`, `ConfigGeneratorRole`) の信頼ポリシー内で使用され、AWS Lambda サービスがこれらのロールを引き受けて、ロールに付与された権限を行使できるように許可しています。
*   **関連:** [IAM](#iam-identity-and-access-management), [IAM Role](#iam-role), 信頼ポリシー, プリンシパル

**IaC (Infrastructure as Code)**
*   **初心者向け解説:** システムの土台となるインフラ（サーバー、ネットワーク、データベースなどの構成）を、手作業で設定する代わりに、コード（プログラム）で記述して管理する手法のことです。「コードでインフラを記述する」ことからこの名前が付いています。[AWS CDK](#aws-cdk-cloud-development-kit) や [CloudFormation](#cloudformation) は、IaC を実現するためのツールです。コードで管理することで、設定ミスを防ぎ、同じ構成を何度も正確に再現したり、変更履歴を管理したりするのが容易になります。
*   **技術的な解説:** インフラストラクチャのプロビジョニングと管理を、手動プロセスではなくコードとソフトウェア開発プラクティス (バージョン管理、テスト、CI/CD など) を通じて行うアプローチ。宣言的な構成ファイル (例: CloudFormation テンプレート) や命令的なスクリプト (例: CDK コード) を使用します。再現性、一貫性、変更管理の容易さ、自動化の促進などのメリットがあります。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [CloudFormation](#cloudformation), 自動化, バージョン管理, DevOps

**ID Token (Cognito)**
*   **初心者向け解説:** [Amazon Cognito](#amazon-cognito) でユーザーが正常にログインできたときに発行される、「デジタル身分証明書」のようなものです。このトークンには、ユーザー名やメールアドレスなど、認証されたユーザーに関する情報が含まれており、かつ電子署名されているため偽造が困難です。フロントエンドのアプリは、この ID トークンをバックエンドの API に提示することで、「私は正当なユーザーです」と証明し、API 機能を利用する許可を得ます。
*   **技術的な解説:**
    *   **定義:** [OpenID Connect (OIDC)](#openid-connect-oidc) フローの一部として [Amazon Cognito](#amazon-cognito) によって発行される [JSON Web Token (JWT)](#jwt-json-web-token) です。認証されたユーザーに関する情報 (ユーザー識別子 `sub`, 発行者 `iss`, 対象者 `aud`, 有効期限 `exp`, 発行日時 `iat`, ユーザー名 `cognito:username`, Eメール `email` など) のクレームを含みます。クライアント (フロントエンド) がユーザー認証の事実を確認するために使用します。通常、API へのアクセス権限を示す Access Token とは別に発行されますが、API Gateway の Cognito オーソライザーは ID Token を検証して認可を行うことも可能です。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` では、`Auth.currentSession().then(session => session.getIdToken().getJwtToken())` を使用して、ログイン済みユーザーの ID トークンを取得しています。取得したトークンは、バックエンド API ([API Gateway](#amazon-api-gateway)) へのリクエストの [`Authorization` ヘッダー](#authorization-header)に `Bearer` スキームで含めて送信されます。API Gateway に設定された Cognito オーソライザーが、この ID トークンの署名、有効期限、発行者などを検証し、リクエストの認証・認可を行います。
*   **関連:** [Amazon Cognito](#amazon-cognito), [JWT](#jwt-json-web-token), [OIDC](#openid-connect-oidc), 認証, [Authorization Header](#authorization-header), クレーム

**Inference Parameters (Bedrock)**
*   **初心者向け解説:** [Amazon Bedrock](#amazon-bedrock) の AI モデルに文章生成などをお願いする際に、応答の「質」や「スタイル」を調整するための「つまみ」や「設定オプション」のことです。例えば、「応答の長さの上限」「応答の創造性の度合い（どれくらい自由な発想をさせるか）」「特定の言葉が出てきたら応答を止める」などを指定できます。
*   **技術的な解説:**
    *   **定義:** [Amazon Bedrock](#amazon-bedrock) のモデル呼び出し (`invoke_model` API など) 時に指定できる、応答生成の挙動を制御するためのパラメータです。モデルによってサポートされるパラメータは異なりますが、共通してよく使われるものに以下があります。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` では、`invoke_model` API のペイロード内で `inferenceConfig` (またはモデルによってはトップレベルに直接) として以下のパラメータが設定されています。
        *   `maxTokens` (または `max_tokens_to_sample` など): 生成する最大トークン数。応答の長さを制限します。
        *   `temperature`: 応答のランダム性を制御します (0に近いほど決定的で一貫性があり、1に近いほど多様で創造的)。
        *   `topP`: Top-P (Nucleus) サンプリング。確率の高いトークンから累積確率が P に達するまでの候補に絞って次のトークンを選択します。`temperature` とは異なる方法でランダム性を制御します。
        *   `stopSequences` (または `stop_sequences`): 生成を停止する特定の文字列シーケンス。モデルがこのシーケンスを生成しようとした時点で応答を打ち切ります。
*   **関連:** [Amazon Bedrock](#amazon-bedrock), [LLM (大規模言語モデル)](#llm-large-language-model), [Token (LLM)](#token-llm), 生成AI

**invoke_model (Bedrock API)**
*   **初心者向け解説:** [Amazon Bedrock](#amazon-bedrock) サービスに対して、「指定した AI モデルを使って、この入力に基づいて応答を生成してください」とお願いするための「命令」（API アクション）の名前です。プログラム (このプロジェクトでは Lambda 関数) は、この命令を使って Bedrock の AI 機能を利用します。
*   **技術的な解説:**
    *   **定義:** [Amazon Bedrock](#amazon-bedrock) サービスにおいて、指定した基盤モデル (FM) を呼び出して推論 (テキスト生成、埋め込みベクトル生成など) を実行するための主要な API アクションです。同期的にモデルを呼び出し、結果を返します (ストリーミング応答の場合は `invoke_model_with_response_stream` を使用)。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` の `ChatFunction` Lambda が、[Bedrock Runtime Client](#bedrock-runtime-client-boto3) を介してこの API を呼び出しています。`modelId` (使用するモデルの ID), `body` (JSON 形式のペイロード。入力プロンプト、[会話履歴](#conversation-history)、[推論パラメータ](#inference-parameters-bedrock) などを含む), `contentType` (`application/json`), `accept` (`application/json`) などを引数として渡しています。
*   **関連:** [Amazon Bedrock](#amazon-bedrock), [Bedrock Runtime Client](#bedrock-runtime-client-boto3), [Boto3](#boto3), [API](#api-application-programming-interface), 推論

**Jest**
*   **初心者向け解説:** JavaScript のプログラムが正しく動作するかどうかを確認するための「テストツール」です。開発者が書いたコードが、期待通りの結果を返すかを自動でチェックしてくれます。バグを早期に発見したり、コードを変更した際に意図しない影響が出ていないかを確認したりするのに役立ちます。
*   **技術的な解説:**
    *   **定義:** Facebook (現 Meta) によって開発された、シンプルさを重視した JavaScript テストフレームワークです。ユニットテスト、統合テスト、スナップショットテストなどに使用され、テストランナー、アサーションライブラリ、モック機能などを内蔵しています。設定が少なくすぐに使い始められる点が特徴です。
    *   **プロジェクトでの役割:** ルートの `simplechat/package.json` の `devDependencies` に `jest` と `ts-jest` (TypeScript コードを Jest でテストするためのプリプロセッサ) が含まれており、`scripts` に `"test": "jest"` が定義されています。これにより、`npm run test` コマンドでプロジェクト (主に CDK コードなど) のテストを実行できます (ただし、リポジトリ内に具体的なテストコード `.test.ts` ファイルは現時点では見当たりません)。フロントエンド (`simplechat/frontend/package.json`) では [`react-scripts test`](#react-scripts-react-scripts) コマンドが内部的に Jest を使用して React コンポーネントのテストを実行します ([React Testing Library](#react-testing-library-testing-libraryreact) と連携)。
*   **関連:** テストフレームワーク, JavaScript, [TypeScript](#typescript), ユニットテスト, 統合テスト, [package.json](#packagejson), [react-scripts](#react-scripts-react-scripts)

**JSON (JavaScript Object Notation)**
*   **初心者向け解説:** コンピュータプログラム同士がデータをやり取りする際によく使われる、「データの書き方のルール（形式）」の一つです。`"名前": "値"` のようなペアで情報を記述し、人間にも比較的読みやすく、プログラムでも扱いやすいのが特徴です。インターネットを介した API 通信などで、リクエストやレスポンスのデータを表現するためによく使われます。
*   **技術的な解説:**
    *   **定義:** 軽量なデータ交換フォーマットです。人間にとって読み書きが容易で、機械にとっても簡単に解析や生成ができます。キーと値のペア (オブジェクト `{}`), 順序付けられた値のリスト (配列 `[]`), 文字列 (`""`), 数値, ブーリアン (`true`/`false`), `null` で構成されます。JavaScript のオブジェクトリテラル構文のサブセットに基づいています。
    *   **プロジェクトでの役割:** このプロジェクトでは広く使用されています。
        *   [API Gateway](#amazon-api-gateway) と [Lambda](#aws-lambda) 間のリクエスト/レスポンスボディは JSON 形式です。
        *   [Bedrock](#amazon-bedrock) API のリクエスト (`body`) およびレスポンスボディも JSON 形式です。
        *   `simplechat/lambda/index.py` では、API Gateway からのイベントボディや Bedrock からのレスポンスボディを扱うために `json.loads()` (JSON 文字列を Python オブジェクトにデコード) と `json.dumps()` (Python オブジェクトを JSON 文字列にエンコード) が使用されています。
        *   [`cdk.json`](#cdkjson) や [`package.json`](#packagejson) などの設定ファイルも JSON 形式で記述されています。
*   **関連:** データ形式, シリアライゼーション, デシリアライゼーション, [API](#api-application-programming-interface)

**JSX (JavaScript XML)**
*   **初心者向け解説:** [React](#react) でウェブページの見た目 (UI) を作る際に使われる、HTML に似た特別な書き方です。JavaScript のコードの中に、`<div>` や `<button>` といった HTML タグのようなものを直接書けるため、どのような UI が作られるのかが直感的に分かりやすくなります。最終的には通常の JavaScript のコードに変換されて実行されます。
*   **技術的な解説:**
    *   **定義:** JavaScript の構文拡張で、ECMAScript (JavaScript の標準仕様) に XML/HTML ライクな構文を導入します。[React](#react) で UI 構造を宣言的に記述するためによく使用されます。Babel などのトランスパイラによって、`React.createElement()` のような通常の JavaScript 関数呼び出しに変換されます。属性はキャメルケース (`className`, `onClick`) で記述し、JavaScript の式を `{}` で埋め込むことができます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` の `ChatInterface` および `App` コンポーネントの `return` 文の中で、UI を構築するために JSX が使用されています。`<div>`, `<h1>`, `<button>`, `<form>`, `<textarea>` といった要素を記述し、CSS クラスの指定 (`className="message user"`) やイベントハンドラーの割り当て (`onSubmit={handleSubmit}`), JavaScript 変数や式の埋め込み (`{user.username}`, `{messages.map(...) }`) などが行われています。
*   **関連:** [React](#react), [Component (React)](#component-react), UI 開発, JavaScript, HTML

**JWT (JSON Web Token)**
*   **初心者向け解説:** インターネット上で、二者間（例えば、ウェブサイトとユーザーのブラウザ）で安全に情報（特に「私は誰か」という認証情報）をやり取りするための「デジタル証明書」の一種です。コンパクトで、電子署名が付いているため、改ざんされていないかを確認できます。[Amazon Cognito](#amazon-cognito) が発行する [ID Token](#id-token-cognito) は、この JWT という形式で作られています。
*   **技術的な解説:**
    *   **定義:** クレーム (Claims、表明) を当事者間で安全に転送するためのコンパクトで自己完結した方法を定義するオープン標準 (RFC 7519) です。JSON オブジェクトとしてエンコードされたクレームセットが、デジタル署名 (JWS) または暗号化 (JWE) され、Base64URL エンコードされた形式 (通常 `header.payload.signature` の形) で表現されます。認証 (ユーザー識別情報の伝達) や認可 (アクセス権限情報の伝達)、情報交換に広く使用されます。
    *   **プロジェクトでの役割:** [Amazon Cognito](#amazon-cognito) がユーザー認証成功後に発行する [ID Token](#id-token-cognito) は JWT 形式です。このトークンにはユーザーに関するクレームが含まれ、Cognito によって署名されています。フロントエンドはこの JWT を取得し、バックエンド API ([API Gateway](#amazon-api-gateway)) へのリクエストの [`Authorization` ヘッダー](#authorization-header)に含めます。API Gateway の Cognito オーソライザーは、この JWT の署名を検証し、有効期限などをチェックすることで、リクエスト元が正当な認証済みユーザーであることを確認します。
*   **関連:** 認証, 認可, [ID Token](#id-token-cognito), [OIDC](#openid-connect-oidc), セキュリティ, [Amazon Cognito](#amazon-cognito), [JSON](#json-javascript-object-notation)

**Lambda Context**
*   **初心者向け解説:** [AWS Lambda](#aws-lambda) 関数が実行されるときに、その実行に関する様々な「状況情報」が 담긴 オブジェクトです。例えば、「あとどれくらい実行時間が残っているか」「この実行の識別番号は何か」「ログはどこに記録されているか」といった情報が含まれています。Lambda 関数はこれらの情報を利用して、自身の動作を制御したり、ログを追跡したりできます。
*   **技術的な解説:**
    *   **定義:** [AWS Lambda](#aws-lambda) 関数のハンドラーメソッドに、`event` オブジェクトと共に渡される2番目の引数 (`context`) です。実行中の Lambda 関数に関するランタイム情報を提供するオブジェクトで、以下のようなプロパティを持ちます:
        *   `function_name`, `function_version`, `invoked_function_arn`: 関数自身の情報。
        *   `memory_limit_in_mb`: 設定されたメモリ量。
        *   `aws_request_id`: このリクエストの一意な ID。
        *   `log_group_name`, `log_stream_name`: CloudWatch Logs の出力先。
        *   `get_remaining_time_in_millis()`: タイムアウトまでの残り時間をミリ秒で返すメソッド。
    *   **プロジェクトでの役割:** `simplechat/lambda/index.py` の `lambda_handler` 関数では、第2引数 `context` を受け取っています。`context.invoked_function_arn` を使用して、関数が実行されている AWS リージョンを特定するために ARN を取得しています。また、(このコードにはありませんが) カスタムリソースの実装などでは、`context.log_stream_name` を CloudFormation に返す PhysicalResourceId として利用したり、`get_remaining_time_in_millis()` で残り実行時間を確認したりすることがあります。
*   **関連:** [AWS Lambda](#aws-lambda), Lambda ハンドラー, ランタイム環境

**Lambda Function (CDK)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) を使って、[AWS Lambda](#aws-lambda) 関数（サーバーレスでコードを実行する部品）を定義するための「設計図部品」です。どのプログラムコードを使うか、どのプログラミング言語 (Python, Node.js など) で動かすか、どれくらいのメモリを割り当てるか、どんな権限 ([IAM Role](#iam-role)) を持たせるか、などをコードで指定します。
*   **技術的な解説:**
    *   **定義:** [AWS CDK](#aws-cdk-cloud-development-kit) で [AWS Lambda](#aws-lambda) 関数リソースを定義するための[コンストラクト](#construct-cdk)です (例: `aws-cdk-lib/aws-lambda.Function` や `aws-cdk-lib/aws-lambda-nodejs.NodejsFunction`, `aws-cdk-lib/aws-lambda-python-alpha.PythonFunction`)。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` 内で、`ChatFunction` (Python) と `ConfigGeneratorFunction` (Node.js) は、`new lambda.Function(...)` コンストラクトを使用して作成されています。このコンストラクトのプロパティで、ランタイム (例: `lambda.Runtime.PYTHON_3_9`), ハンドラー (実行される関数名、例: `index.lambda_handler`), コードの場所 (`lambda.Code.fromAsset('lambda')`), 割り当てる [IAM Role](#iam-role), [環境変数](#environment-variables-環境変数) (`environment`), タイムアウト時間、メモリサイズなどを指定しています。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [AWS Lambda](#aws-lambda), [Construct (CDK)](#construct-cdk), [IAM Role](#iam-role), [Environment Variables](#environment-variables-環境変数)

**Lambda Integration (API Gateway)**
*   **初心者向け解説:** [API Gateway](#amazon-api-gateway) (総合受付) が受け取ったリクエストを、実際に処理を行う [AWS Lambda](#aws-lambda) 関数 (担当部署) に「つなぐ」ための設定です。これにより、API Gateway への特定のアクセス (例: `/chat` への POST リクエスト) があったときに、対応する Lambda 関数が自動的に呼び出されるようになります。
*   **技術的な解説:**
    *   **定義:** [Amazon API Gateway](#amazon-api-gateway) のメソッド (特定の HTTP メソッドとリソースパスの組み合わせ) へのリクエストを、バックエンドの [AWS Lambda](#aws-lambda) 関数に転送するための統合タイプです。主なタイプに以下の2つがあります。
        *   **Lambda Proxy Integration (プロキシ統合):** API Gateway は受信した HTTP リクエスト全体をそのまま Lambda 関数の `event` オブジェクトにマッピングして渡し、Lambda 関数の戻り値を特定の形式 (statusCode, headers, body を含む JSON) で返すことを期待し、それを HTTP レスポンスに変換します。設定がシンプルです。
        *   **Lambda Custom Integration (非プロキシ統合):** API Gateway でリクエストとレスポンスのマッピングを細かく定義できます。より柔軟な制御が可能ですが、設定が複雑になります。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` で `new apigateway.LambdaIntegration(chatFunction)` は、`/chat` エンドポイントへの POST リクエストを `ChatFunction` Lambda に統合するために使用されています。コードからは明示的にプロキシかカスタムか判別できませんが、Lambda 関数の `event` の構造や戻り値の形式から、**Lambda Proxy Integration** が使用されている可能性が高いと推測されます。これにより、フロントエンドからのチャットリクエストが `ChatFunction` Lambda に渡され、その応答がフロントエンドに返されます。
*   **関連:** [Amazon API Gateway](#amazon-api-gateway), [AWS Lambda](#aws-lambda), [API Gateway Event (Lambda Proxy Integration)](#api-gateway-event-lambda-proxy-integration), REST API

**LLM (Large Language Model)**
*   **初心者向け解説:** インターネット上の膨大な量の文章データを学習して、人間のように言葉を理解したり、文章を生成したり、質問に答えたりできる、非常に高性能な「AI の頭脳」のことです。ChatGPT などが有名です。[Amazon Bedrock](#amazon-bedrock) は、様々な種類の LLM を利用できるようにしてくれるサービスです。このプロジェクトのチャットボットは、この LLM を使ってユーザーと対話しています。
*   **技術的な解説:** 大量のテキストデータで事前学習された、深層学習モデル (特に Transformer アーキテクチャに基づくことが多い) の一種。数十億から数兆のパラメータを持ち、テキストの生成、要約、翻訳、質問応答、感情分析など、多様な自然言語処理 (NLP) タスクを高い精度で実行できます。プロンプトエンジニアリングによって特定のタスクへの適応が可能です。
*   **関連:** [Amazon Bedrock](#amazon-bedrock), AI (人工知能), NLP (自然言語処理), 生成AI, 基盤モデル (FM), [Token (LLM)](#token-llm)

**Node.js**
*   **初心者向け解説:** 通常はウェブブラウザの中で動く JavaScript というプログラミング言語を、サーバーサイド（ウェブサイトの裏側）など、ブラウザ以外の場所でも動かせるようにするための「実行環境」です。これにより、JavaScript を使ってウェブサーバーを立てたり、開発ツールを作ったりできます。このプロジェクトでは、[AWS CDK](#aws-cdk-cloud-development-kit) (インフラ構築ツール) を動かしたり、フロントエンド ([React](#react)) の開発・ビルドを行ったり、一部の Lambda 関数 (`ConfigGeneratorFunction`) を実行したりするために Node.js が使われています。
*   **技術的な解説:**
    *   **定義:** Chrome の V8 JavaScript エンジン上に構築された、イベント駆動型でノンブロッキング I/O モデルを採用した JavaScript ランタイム環境です。サーバーサイドアプリケーション、API、コマンドラインツール、ビルドツールなどの開発に適しています。
    *   **プロジェクトでの役割:** [AWS CDK](#aws-cdk-cloud-development-kit) は Node.js 上で動作するため、CDK コマンドの実行に Node.js が必須です。また、フロントエンド ([React](#react)) の開発環境 (`npm start`) や本番ビルド (`npm run build`) も Node.js 上で動作するツール ([react-scripts](#react-scripts-react-scripts)) を利用しています。さらに、設定ファイルを生成する `ConfigGeneratorFunction` Lambda も Node.js ランタイムで実行されます。[npm](#npm-node-package-manager) は Node.js のデフォルトのパッケージマネージャーであり、プロジェクト全体の依存関係管理やスクリプト実行に不可欠です ([package.json](#packagejson) を参照)。
*   **関連:** JavaScript ランタイム, [npm](#npm-node-package-manager), [package.json](#packagejson), [AWS CDK](#aws-cdk-cloud-development-kit), [AWS Lambda](#aws-lambda), [フロントエンド](#フロントエンド-frontend), [バックエンド](#バックエンド-backend)

**npm (Node Package Manager)**
*   **初心者向け解説:** [Node.js](#nodejs) で使われる、「プログラム部品（パッケージ）の管理ツール」です。世界中の開発者が作った便利な部品（ライブラリやツール）をインターネット上から簡単に探してきて、自分のプロジェクトにインストールしたり、アップデートしたりできます。また、プロジェクトで使う部品リスト ([package.json](#packagejson)) を管理したり、よく使うコマンド（ビルド、テストなど）を登録して簡単に実行したりする機能もあります。
*   **技術的な解説:**
    *   **定義:** [Node.js](#nodejs) のデフォルトのパッケージマネージャーであり、世界最大のソフトウェアレジストリ (npm Registry) へのインターフェースでもあります。JavaScript のライブラリやツールのインストール (`npm install`)、共有 (`npm publish`)、依存関係管理 (`package.json`, `package-lock.json`)、スクリプト実行 (`npm run`) などの機能を提供します。
    *   **プロジェクトでの役割:** このプロジェクトでは、ルートディレクトリと `frontend` ディレクトリの両方で npm が使用されています。
        *   `package.json` ファイルで依存関係 ([dependencies](#dependencies-packagejson), [devDependencies](#devdependencies-packagejson)) を定義し、`npm install` コマンドでこれらのパッケージを `node_modules` ディレクトリにインストールします。
        *   `package.json` の [`scripts`](#scripts-npm) セクションで定義されたコマンド (例: `build`, `test`, `deploy`, `start`) を `npm run <script_name>` で実行します。
        *   ルートの `postinstall` スクリプト (`npm install` 後に自動実行) により、フロントエンドの依存関係インストールとビルドが自動化されています。
*   **関連:** [Node.js](#nodejs), パッケージマネージャー, [package.json](#packagejson), [dependencies (package.json)](#dependencies-packagejson), [devDependencies (package.json)](#devdependencies-packagejson), [scripts (npm)](#scripts-npm), JavaScript

**OAuth 2.0**
*   **初心者向け解説:** あるウェブサービス（例: Google, Facebook, Cognito）のユーザーが、自分のアカウント情報を直接教えることなく、別のアプリ（サードパーティアプリ）に対して「このアプリに、私のカレンダー情報へのアクセスだけを許可します」といった形で、限定的な「権限」を与えるための仕組み（認可のルール）です。「ログイン情報の代理人」のような役割を果たし、安全にサービス連携を実現します。[Amazon Cognito](#amazon-cognito) もこの仕組みに対応しています。
*   **技術的な解説:**
    *   **定義:** サードパーティアプリケーションによる HTTP サービスへの限定的なアクセス（スコープに基づいた認可）を可能にするための認可フレームワーク (RFC 6749)。ユーザーの認証情報 (パスワードなど) をサードパーティアプリケーションに渡すことなく、リソースオーナー (ユーザー) の代理としてリソースサーバー (API など) へのアクセス権限を付与するフロー (Authorization Code Grant, Implicit Grant, Client Credentials Grant, Resource Owner Password Credentials Grant など) を定義します。Access Token を用いて保護されたリソースへのアクセスを行います。
    *   **プロジェクトでの役割:** [Amazon Cognito](#amazon-cognito) は OAuth 2.0 の認可サーバーとしても機能します。`simplechat/lib/bedrock-chatbot-stack.ts` の [UserPool Client](#userpool-client-cognito) 設定で `oAuth` ブロックが定義されており、`flows` (Implicit Grant, Authorization Code Grant の有効化), `scopes` ([OAuth Scope](#oauth-scope-cognito): `openid`, `email`, `profile`), `callbackUrls`, `logoutUrls` が設定されています。これにより、フロントエンドアプリケーションは Cognito を介して OAuth 2.0 フローを実行し、(主に OIDC 用の) トークンを取得できます。Amplify ライブラリがこれらのフローを内部で処理します。
*   **関連:** [Amazon Cognito](#amazon-cognito), [OpenID Connect](#openid-connect-oidc), [Scope (OAuth)](#oauth-scope-cognito), 認可, Access Token, [ID Token](#id-token-cognito)

**OpenID Connect (OIDC)**
*   **初心者向け解説:** [OAuth 2.0](#oauth-20) という権限付与の仕組みの上に、「ユーザー認証」の機能を追加したものです。OAuth 2.0 が「何を許可するか」に焦点を当てているのに対し、OIDC は「誰がログインしたか」を安全に確認し、そのユーザーの基本的な情報（名前、メールアドレスなど）を取得する標準的な方法を提供します。[Amazon Cognito](#amazon-cognito) は OIDC プロバイダーとしても機能し、ログイン時に [ID Token](#id-token-cognito) (JWT 形式の身分証明書) を発行します。
*   **技術的な解説:**
    *   **定義:** [OAuth 2.0](#oauth-20) プロトコルに基づいたシンプルなアイデンティティレイヤーです。クライアント (Relying Party, RP) が、Authorization Server (OpenID Provider, OP) によるエンドユーザーの認証に基づいてアイデンティティを確認し、基本的なプロファイル情報を相互運用可能な形で取得できるようにします。認証の証明として [ID Token](#id-token-cognito) (JWT) を使用します。`openid` スコープのリクエストが OIDC フローを示します。
    *   **プロジェクトでの役割:** [Amazon Cognito](#amazon-cognito) は OpenID Provider (OP) として機能します。フロントエンド ([React](#react) + [Amplify](#aws-amplify)) は Relying Party (RP) として Cognito と OIDC フロー (主に Implicit Grant または Authorization Code Grant) を実行し、認証後に [ID Token](#id-token-cognito) を受け取ります。この ID トークンには `sub` (ユーザー固有 ID), `email`, `cognito:username` などのクレームが含まれており、フロントエンドはこれを利用してユーザー情報を表示したり、バックエンド API ([API Gateway](#amazon-api-gateway)) へのリクエストに添付して認証を行ったりします。UserPool Client 設定で `openid`, `email`, `profile` といった OIDC 標準スコープが有効化されています。
*   **関連:** [Amazon Cognito](#amazon-cognito), [OAuth 2.0](#oauth-20), [ID Token](#id-token-cognito), [JWT](#jwt-json-web-token), 認証, アイデンティティ

**package.json**
*   **初心者向け解説:** [Node.js](#nodejs) を使ったプロジェクト（CDK アプリや React アプリなど）の「説明書」兼「部品リスト」のようなファイルです。プロジェクトの名前、バージョン、作者といった基本情報に加えて、このプロジェクトが依存している外部のプログラム部品（パッケージ）のリスト ([dependencies](#dependencies-packagejson), [devDependencies](#devdependencies-packagejson)) や、よく使うコマンド（ビルド、テスト、実行など）のショートカット ([scripts](#scripts-npm)) が [JSON](#json-javascript-object-notation) という形式で書かれています。[npm](#npm-node-package-manager) ツールはこのファイルを読んで、必要な部品をインストールしたり、コマンドを実行したりします。
*   **技術的な解説:**
    *   **定義:** [Node.js](#nodejs) プロジェクトに関するメタデータ (プロジェクト名、バージョン、ライセンスなど) や、プロジェクトの依存関係 ([npm](#npm-node-package-manager) で管理されるパッケージ: [dependencies](#dependencies-packagejson), [devDependencies](#devdependencies-packagejson))、および実行可能なスクリプト ([scripts](#scripts-npm) フィールド) などを定義する [JSON](#json-javascript-object-notation) ファイルです。Node.js プロジェクトのルートディレクトリに配置され、`npm init` コマンドで生成できます。`npm install` はこのファイルを読み込んでパッケージをインストールします。
    *   **プロジェクトでの役割:** このリポジトリには2つの `package.json` があります。
        *   ルート (`simplechat/package.json`): 主に [AWS CDK](#aws-cdk-cloud-development-kit) アプリケーションの依存関係 (`aws-cdk-lib`, `constructs` など) と開発依存関係 (`typescript`, `jest`, `aws-cdk` など) を管理します。また、CDK コマンドのショートカットや、フロントエンドのビルドを含む全体のセットアップを行う `postinstall` スクリプトを定義しています。
        *   フロントエンド (`simplechat/frontend/package.json`): [React](#react), [axios](#axios), [Amplify](#aws-amplify) ライブラリなど、フロントエンドアプリケーションの実行に必要な依存関係と、[Create React App](#create-react-app-cra) が提供する [`react-scripts`](#react-scripts-react-scripts) を使ったビルド/開発スクリプト (`start`, `build`, `test`) を管理します。ESLint や browserslist の設定も含まれています。
*   **関連:** [Node.js](#nodejs), [npm](#npm-node-package-manager), 依存関係管理, [JSON](#json-javascript-object-notation), [dependencies (package.json)](#dependencies-packagejson), [devDependencies (package.json)](#devdependencies-packagejson), [scripts (npm)](#scripts-npm)

**postinstall (npm script)**
*   **初心者向け解説:** [package.json](#packagejson) の中で定義できる特別なスクリプトの一つで、`npm install` コマンドを使って必要なプログラム部品のインストールが**完了した直後に自動的に実行される**コマンドです。プロジェクトの初期設定やビルドなど、インストール後に必ず行いたい作業を自動化するのに便利です。
*   **技術的な解説:**
    *   **定義:** [`package.json`](#packagejson) の [`scripts`](#scripts-npm) セクションで定義できる特殊なライフサイクルスクリプト名の一つです。`npm install` コマンドが依存関係のインストールを正常に完了した後に、npm によって自動的に実行されます。
    *   **プロジェクトでの役割:** ルートの `simplechat/package.json` の `scripts` 内で `"postinstall": "cd frontend && npm install && npm run build"` と定義されています。これにより、開発者がリポジトリをクローンしてルートディレクトリで `npm install` を一度実行するだけで、自動的に以下の処理が行われます。
        1.  `frontend` ディレクトリに移動 (`cd frontend`)。
        2.  フロントエンドの依存関係をインストール (`npm install`)。
        3.  フロントエンドのアプリケーションを本番用にビルド (`npm run build`)。
    これにより、プロジェクトのセットアップ手順が簡略化され、開発開始までの手間が省かれます。
*   **関連:** [npm](#npm-node-package-manager), [package.json](#packagejson), [scripts (npm)](#scripts-npm), 自動化, ビルドプロセス, ライフサイクルスクリプト

**Props (React)**
*   **初心者向け解説:** [React](#react) のコンポーネント（UI 部品）間でデータを「受け渡し」するための仕組みです。親コンポーネントから子コンポーネントへ、情報を伝えるために使われます。例えば、親が持っているユーザー名を子のヘッダー部品に渡して表示させる、といった場合に利用します。子コンポーネントは Props を受け取って使いますが、原則として中身を書き換えることはできません（読み取り専用）。
*   **技術的な解説:**
    *   **定義:** Properties の略。[React](#react) [コンポーネント](#component-react)間でデータを渡すための仕組みです。親コンポーネントから子コンポーネントへ、HTML 属性のような形式で値を渡します。子コンポーネントは関数コンポーネントの場合は引数として、クラスコンポーネントの場合は `this.props` として受け取ります。Props はイミュータブル (変更不可) であり、親から子への単方向のデータフローを形成します。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` では、`App` コンポーネント (親) が [Authenticator](#authenticator-component-amplify-ui) から `signOut` 関数と `user` オブジェクトを受け取り、それらを子コンポーネントである `ChatInterface` に props として渡しています (`<ChatInterface signOut={signOut} user={user} />`)。`ChatInterface` コンポーネントは、`function ChatInterface({ signOut, user })` のように分割代入を使ってこれらの props を受け取り、ログアウトボタンの処理やユーザー名の表示に使用しています。
*   **関連:** [React](#react), [Component (React)](#component-react), データフロー, 親子関係

**Python**
*   **初心者向け解説:** プログラミング言語の一つで、比較的文法がシンプルで読み書きしやすく、初心者にも人気があります。ウェブ開発、データ分析、AI (人工知能)、自動化など、様々な分野で広く使われています。このプロジェクトでは、バックエンドでチャット応答を生成する [AWS Lambda](#aws-lambda) 関数 (`ChatFunction`) が Python で書かれています。
*   **技術的な解説:**
    *   **定義:** インタプリタ型、オブジェクト指向、動的型付けを持つ高水準汎用プログラミング言語です。読みやすく、簡潔な構文と、豊富な標準ライブラリおよびサードパーティ製パッケージエコシステム (PyPI) を特徴とします。
    *   **プロジェクトでの役割:** このプロジェクトのバックエンドの中核ロジックである `ChatFunction` Lambda (`simplechat/lambda/index.py`) は Python 3.9 (CDK コード内のランタイム指定による) で記述されています。この Lambda 関数は、API Gateway からのリクエストを処理し、[Boto3](#boto3) ライブラリを使用して [Amazon Bedrock](#amazon-bedrock) サービスと連携し、LLM からの応答を取得してフロントエンドに返します。依存ライブラリ ([Boto3](#boto3) など) は `simplechat/lambda/requirements.txt` で管理されます。
*   **関連:** プログラミング言語, [AWS Lambda](#aws-lambda), [Boto3](#boto3), [requirements.txt](#requirementstxt), [バックエンド](#バックエンド-backend)

**React**
*   **初心者向け解説:** Facebook (現 Meta) が開発した、ウェブページのユーザーインターフェース (UI)、つまり「見た目」の部分を作るための JavaScript ライブラリ（便利な道具箱）です。[コンポーネント](#component-react)という再利用可能な部品を組み合わせて UI を構築するのが特徴です。データの変更に応じて画面表示が自動的に効率よく更新されるため、複雑な UI を持つウェブアプリの開発に適しています。このプロジェクトのフロントエンド (チャット画面) は React を使って作られています。
*   **技術的な解説:**
    *   **定義:** ユーザーインターフェース (UI) を構築するための宣言的な、効率的で柔軟な JavaScript ライブラリです。[コンポーネント](#component-react)ベースのアーキテクチャを採用しており、仮想 DOM (Virtual DOM) を利用して効率的な DOM 更新を行います。単方向データフローや、[React Hooks](#react-hooks) による関数コンポーネントでの状態管理・副作用処理などが特徴です。
    *   **プロジェクトでの役割:** このプロジェクトのフロントエンド (`simplechat/frontend/`) は React を使用して構築されています。`simplechat/frontend/src/App.js` はメインの React コンポーネントを含み、[JSX](#jsx-javascript-xml) を使用して UI を宣言的に記述し、[React Hooks](#react-hooks) (`useState`, `useEffect`, `useRef`) を使用してチャットメッセージ、入力状態、ローディング状態などの管理や、API 呼び出し、DOM 操作といった副作用処理を行っています。依存関係は `simplechat/frontend/package.json` で管理されています。
*   **関連:** JavaScript ライブラリ, [フロントエンド](#フロントエンド-frontend), UI, [Component (React)](#component-react), [JSX](#jsx-javascript-xml), [React Hooks](#react-hooks), 仮想 DOM, [package.json](#packagejson)

**ReactDOM**
*   **初心者向け解説:** [React](#react) で作った UI 部品（コンポーネント）を、実際にウェブブラウザの画面に表示（レンダリング）するための道具です。React 本体が部品の設計図を作る役割だとすると、ReactDOM はその設計図をもとに実際に画面に組み立てる役割を担います。
*   **技術的な解説:**
    *   **定義:** [React](#react) をブラウザの [DOM](#dom-document-object-model) にレンダリングするためのパッケージです。React 本体 (`react` パッケージ) から分離されており、ウェブ以外の環境 (例: React Native) では異なるレンダラーが使用されます。React 18 からは `react-dom/client` パッケージの `createRoot` API を使用してレンダリングを開始するのが推奨されています。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/index.js` で `import ReactDOM from 'react-dom/client'` され、`ReactDOM.createRoot(document.getElementById('root'))` で HTML 内の `<div id="root">` 要素に対応するレンダリングルートを作成し、その `root.render()` メソッドでメインの `<App />` コンポーネントを DOM に描画するために使用されています。これが React アプリケーションの起動プロセスとなります。
*   **関連:** [React](#react), [DOM](#dom-document-object-model), レンダリング, [フロントエンド](#フロントエンド-frontend)

**React Hooks**
*   **初心者向け解説:** [React](#react) の関数型コンポーネント（シンプルな形の UI 部品）の中で、クラス型コンポーネント（少し複雑な形の部品）にしかなかったような機能（状態管理やライフサイクル機能など）を使えるようにするための特別な関数群です。例えば、`useState` はコンポーネント内で変化する値（状態）を保持するため、`useEffect` は特定のタイミングで処理を実行するために使います。これにより、よりシンプルに関数だけで React コンポーネントを書けるようになりました。
*   **技術的な解説:**
    *   **定義:** React 16.8 で導入された機能で、関数コンポーネント内で [State](#state-react) やその他の React の機能 (ライフサイクルメソッドに相当する副作用処理、コンテキストなど) を利用できるようにする関数群です。`use` で始まる名前を持ちます (例: `useState`, `useEffect`, `useContext`, `useReducer`, `useCallback`, `useMemo`, `useRef`)。クラスコンポーネントを書かずに、より多くの React の機能を利用可能にします。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` の `ChatInterface` コンポーネントでは以下のフックが広く使用されています。
        *   `useState`: `messages` (会話履歴), `input` (入力テキスト), `loading` (API 通信中フラグ), `error` (エラーメッセージ) といった、コンポーネントの内部状態を管理します。
        *   `useEffect`: `messages` ステートが変更されたときに、チャットウィンドウを最下部に自動スクロールする副作用を実行します。
        *   `useRef`: メッセージリストの末尾の DOM 要素への参照 (`messagesEndRef`) を保持し、`useEffect` 内でスクロール位置の制御に使用します。
*   **関連:** [React](#react), 関数コンポーネント, [State (React)](#state-react), 副作用 (Side Effect), コンポーネントライフサイクル, [useState](#state-react), [useEffect](#effect-hook-useeffect), [useRef](#ref-hook-useref)

**React Scripts (react-scripts)**
*   **初心者向け解説:** [Create React App (CRA)](#create-react-app-cra) というスターターキットに含まれている、React アプリ開発に必要な様々なコマンド（開発サーバー起動、本番用ファイル作成、テスト実行など）をまとめて実行してくれるプログラムです。開発者は複雑な内部設定を知らなくても、`npm start` や `npm run build` といった簡単なコマンドを使うだけで済みます。
*   **技術的な解説:**
    *   **定義:** [Create React App (CRA)](#create-react-app-cra) によって提供されるスクリプトと設定のセットです。React アプリケーションの開発サーバー起動 (`start`)、本番ビルド (`build`)、テスト実行 (`test`)、設定の展開 (`eject`) といったタスクを内部的に処理します。Webpack, Babel, Jest, ESLint などのツールの設定を抽象化・隠蔽し、"Zero-configuration" (設定不要) な開発体験を提供することを目指しています。
    *   **プロジェクトでの役割:** `simplechat/frontend/package.json` の `dependencies` に含まれており、`scripts` セクションで `start`, `build`, `test`, `eject` コマンドがこの `react-scripts` を呼び出すように定義されています。例えば `npm run build` を実行すると、`react-scripts build` が実行され、最適化された静的ファイルが `build` ディレクトリに生成されます。
*   **関連:** [Create React App (CRA)](#create-react-app-cra), [React](#react), ビルドツール, 開発サーバー, テスト, [package.json](#packagejson), Webpack, Babel, Jest

**React StrictMode**
*   **初心者向け解説:** [React](#react) アプリの開発中に、コードの中にある潜在的な問題点（例えば、古い書き方や推奨されない使い方）を見つけやすくするための「チェック強化モード」です。`<React.StrictMode>` で囲まれた部分のコードに対して、React がより厳格なチェックを行い、問題があれば開発者ツールのコンソールに警告を出してくれます。本番環境での動作には影響しません。
*   **技術的な解説:**
    *   **定義:** [React](#react) アプリケーション内の潜在的な問題を強調するためのツールコンポーネントです。`<React.StrictMode>` でラップされたコンポーネントツリー内のコンポーネントとその子孫に対して、追加のチェックや警告を開発モードでのみ実行します。例えば、安全でないライフサイクルメソッドの使用、レガシーな文字列 ref API の使用、意図しない副作用の検出（一部ライフサイクル関数を意図的に 2 回呼び出すなど）、レガシーな Context API の使用などを検出するのに役立ちます。本番ビルドには影響を与えません。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/index.js` で、アプリケーションのルートコンポーネントである `<App />` 全体が `<React.StrictMode>` でラップされています (`<React.StrictMode><App /></React.StrictMode>`)。これにより、開発中に React が行う追加のチェックが有効になり、開発者は潜在的な問題に関する警告をブラウザのコンソールで確認できます。
*   **関連:** [React](#react), デバッグ, 開発環境, コード品質

**React Testing Library (@testing-library/react)**
*   **初心者向け解説:** [React](#react) で作った UI 部品（コンポーネント）が、ユーザーから見て正しく動作するかどうかをテストするための道具（ライブラリ）です。部品の内部構造（コードの詳細）ではなく、「実際にユーザーがボタンをクリックしたらどうなるか」「特定のテキストが表示されているか」といった、ユーザーの視点に近いテストを書くことを推奨しています。
*   **技術的な解説:**
    *   **定義:** ユーザーがソフトウェアをどのように使用するかに焦点を当てた、[React](#react) コンポーネントのテストを支援するライブラリ群 (`@testing-library/react`, `@testing-library/jest-dom`, `@testing-library/user-event` など) の中核ライブラリ。コンポーネントの実装詳細（内部状態やメソッド）に依存するテストではなく、レンダリングされた DOM ノードを照会し、ユーザーイベントをシミュレートすることで、コンポーネントの動作をテストするアプローチを推奨します。アクセシビリティを考慮したクエリ (getByRole, getByLabelText など) を提供します。
    *   **プロジェクトでの役割:** `simplechat/frontend/package.json` の `dependencies` に `@testing-library/react`, `@testing-library/jest-dom` (Jest 用のカスタム DOM マッチャー), `@testing-library/user-event` (ユーザー操作のシミュレーション) が含まれています。これらは、`simplechat/frontend/src/` ディレクトリ内に `.test.js` や `.spec.js` といった命名規則のテストファイルを作成し、React コンポーネントのユニットテストや統合テストを記述するために使用されることを想定しています (ただし、リポジトリ内に具体的なテストコードは現時点では見当たりません)。テストは [`react-scripts test`](#react-scripts-react-scripts) コマンド (内部で Jest を使用) によって実行されます。
*   **関連:** [React](#react), テストフレームワーク, ユニットテスト, 統合テスト, [Jest](#jest), [package.json](#packagejson)

**Ref Hook (useRef)**
*   **初心者向け解説:** [React](#react) のコンポーネントの中で、特定の画面要素（例えば、入力欄やスクロールさせたい領域）に直接アクセスするための「目印」や「参照」を取得・保持するための機能（フック）です。また、画面の再描画を引き起こさずに、コンポーネント内で値を保持しておきたい場合にも使われます。このプロジェクトでは、チャットのメッセージが増えたときに、一番下のメッセージが表示されるように自動スクロールさせるために、メッセージリストの末尾要素への参照を取得するのに使われています。
*   **技術的な解説:**
    *   **定義:** [React Hooks](#react-hooks) の一つで、2つの主な用途があります:
        1.  レンダリング間で永続的なミュータブル (変更可能) な値を保持する。`.current` プロパティに値を格納し、この値を変更してもコンポーネントの再レンダリングはトリガーされません。
        2.  DOM 要素への直接的な参照を保持する。JSX の `ref` 属性に `useRef` が返すオブジェクトを渡すと、対応する DOM 要素がマウントされたときにその要素への参照が `.current` プロパティに格納されます。これにより、DOM API を直接呼び出すことができます (例: フォーカス設定、サイズ計測、メディア再生制御など)。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` の `ChatInterface` コンポーネントで `const messagesEndRef = useRef(null);` として初期化され、メッセージリストの最後に追加された空の `<div>` 要素に `ref={messagesEndRef}` としてアタッチされています。`useEffect` 内の `scrollToBottom` 関数で `messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })` を呼び出すことにより、この DOM 要素を直接操作し、新しいメッセージが表示されるようにスムーズにスクロールする機能を実現しています。
*   **関連:** [React](#react), [React Hooks](#react-hooks), [DOM](#dom-document-object-model), 参照

**requirements.txt**
*   **初心者向け解説:** [Python](#python) プロジェクトが動作するために必要な外部のプログラム部品（ライブラリ、パッケージ）とそのバージョンをリストアップしたファイルです。このリストに従って、`pip` という Python のパッケージ管理ツールが、必要な部品をインターネットからダウンロードして準備してくれます。プロジェクトを他の環境でも同じように動かすために重要です。
*   **技術的な解説:**
    *   **定義:** [Python](#python) プロジェクトで使用される、依存する外部パッケージとそのバージョンを指定するための標準的なテキストファイル形式です。通常、1行に1パッケージとそのバージョン指定子 (例: `requests==2.28.1`, `numpy>=1.20.0`) が記述されます。`pip install -r requirements.txt` コマンドで、リストされたパッケージとその依存関係を一括インストールできます。
    *   **プロジェクトでの役割:** `simplechat/lambda/requirements.txt` には、`ChatFunction` Lambda が必要とする [`boto3`](#boto3) (AWS SDK for Python) と `botocore` (Boto3 のコアライブラリ) の特定のバージョン (`1.28.0`, `1.31.0`) が記載されています。Lambda 関数のデプロイパッケージを作成する際 (CDK が内部で行うか、手動で行うかに関わらず)、このファイルに基づいてこれらの依存ライブラリが Lambda の実行環境に含められます。これにより、Lambda 関数が期待通りに AWS サービス (特に Bedrock) と通信できるようになります。
*   **関連:** [Python](#python), pip, 依存関係管理, [AWS Lambda](#aws-lambda), [Boto3](#boto3)

**REST API**
*   **初心者向け解説:** ウェブ上でサービス（機能）を公開し、外部のプログラムから利用できるようにするための設計スタイル（考え方）の一つです。インターネットの基本的な通信ルールである HTTP を活用し、「どの情報（リソース）に」「何をするか（HTTP メソッド: GET, POST, PUT, DELETE など）」を URL とメソッドの組み合わせで表現します。シンプルで分かりやすく、多くの Web API で採用されています。このプロジェクトの API Gateway は REST API として設計されています。
*   **技術的な解説:** Representational State Transfer の略。分散ハイパーメディアシステム (ウェブなど) のためのソフトウェアアーキテクチャスタイル。以下の原則に基づいています: クライアント/サーバー分離、ステートレス性 (サーバーがクライアントの状態を保持しない)、キャッシュ可能性、階層化システム、統一インターフェース (リソースの識別、表現によるリソース操作、自己記述的メッセージ、HATEOAS)。一般的に HTTP プロトコル上で実装され、リソースを URL (URI) で識別し、HTTP メソッド (GET, POST, PUT, DELETE など) で操作を表現し、JSON や XML などの形式でリソースの表現を送受信します。
*   **関連:** [API](#api-application-programming-interface), [Amazon API Gateway](#amazon-api-gateway), HTTP, URL, JSON, ステートレス

**S3 Bucket Deployment (CDK)**
*   **初心者向け解説:** [AWS CDK](#aws-cdk-cloud-development-kit) を使って、ローカルのコンピュータにあるファイル（例えば、ビルド済みのフロントエンドのウェブサイトファイル）を、[Amazon S3](#amazon-s3-simple-storage-service) の倉庫（バケット）に自動でアップロードするための「設計図部品」です。さらに、アップロード後に [CloudFront](#amazon-cloudfront) のキャッシュ（一時保管データ）をクリアする設定もできます。
*   **技術的な解説:**
    *   **定義:** ローカルのファイルやディレクトリの内容、または他の S3 バケットのオブジェクトを、指定したデプロイ先の S3 バケットにアップロード・同期するための [AWS CDK](#aws-cdk-cloud-development-kit) ライブラリ (`aws-cdk-lib/aws-s3-deployment`) が提供する高レベル[コンストラクト](#construct-cdk) (`BucketDeployment`) です。CDK デプロイプロセスの一部として実行されます。オプションで、デプロイ後に指定した [CloudFront](#amazon-cloudfront) ディストリビューションのキャッシュを無効化 (Invalidation) することも可能です。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` で `DeployWebsite` という名前で `new s3deploy.BucketDeployment(...)` としてインスタンス化されています。これは、`simplechat/frontend/` ディレクトリで `npm run build` によって生成されたビルド成果物 (HTML, CSS, JS ファイルなど) が格納されている `../frontend/build` ディレクトリの内容を、`WebsiteBucket` (フロントエンドホスティング用の S3 バケット) にアップロードします。さらに、`distribution` と `distributionPaths` プロパティが設定されているため、アップロード完了後に、関連付けられた CloudFront ディストリビューション (`Distribution`) のキャッシュをすべて (`['/*']`) 無効化し、ユーザーが常に最新のフロントエンドファイルにアクセスできるようにします。
*   **関連:** [AWS CDK](#aws-cdk-cloud-development-kit), [Amazon S3](#amazon-s3-simple-storage-service), [Amazon CloudFront](#amazon-cloudfront), デプロイメント, 自動化, キャッシュ無効化

**サーバー (Server)**
*   **初心者向け解説:** ネットワークを通じて、他のコンピュータ（クライアント、例えば皆さんの PC やスマホ）からの要求（リクエスト）に応じて、データやサービスを提供するコンピュータのことです。ウェブサイトのファイルを提供したり、メールを送受信したり、データベースを管理したり、様々な役割があります。このプロジェクトでは、AWS が提供する様々なマネージドサービス（Lambda, API Gateway, S3 など）を利用することで、開発者が物理的なサーバーコンピュータを直接管理する手間を省いています（[サーバーレス](#サーバーレス-serverless)）。
*   **技術的な解説:** クライアント/サーバーモデルにおいて、クライアントからのリクエストを受け付け、処理を実行し、結果やリソースを提供するコンピュータまたはソフトウェアプログラム。Web サーバー, メールサーバー, データベースサーバー, アプリケーションサーバーなど、役割に応じて様々な種類があります。物理的なハードウェアを指す場合と、その上で動作するソフトウェアプロセスを指す場合があります。
*   **関連:** クライアント, ネットワーク, [バックエンド](#バックエンド-backend), [サーバーレス](#サーバーレス-serverless)

**サーバーレス (Serverless)**
*   **初心者向け解説:** アプリケーションを開発・実行する際に、開発者がサーバーコンピュータの存在をほとんど意識しなくてもよい考え方や、それに基づくクラウドサービスの形態のことです。サーバーの購入、OS の設定、ソフトウェアのアップデート、負荷に応じた台数調整などをクラウド事業者 (AWS など) が自動的に行ってくれるため、開発者はアプリケーションのコードを書くことに集中できます。[AWS Lambda](#aws-lambda) は代表的なサーバーレスコンピューティングサービスです。
*   **技術的な解説:** サーバーのプロビジョニング、管理、スケーリングといったインフラストラクチャ管理タスクを開発者から抽象化するクラウドコンピューティングの実行モデル。通常、FaaS (Function as a Service) や BaaS (Backend as a Service) の形態で提供されます。イベント駆動型で、リクエストやイベントに応じてコードが実行され、実行時間やリソース消費量に基づいて課金されることが多いです。スケーラビリティ、コスト効率、開発速度の向上が期待できますが、ステート管理や実行時間制限などの制約もあります。
*   **関連:** [AWS Lambda](#aws-lambda), FaaS, BaaS, クラウドコンピューティング, [サーバー](#サーバー-server)

**scripts (npm)**
*   **初心者向け解説:** [package.json](#packagejson) ファイルの中に定義される、よく使うコマンドライン操作の「ショートカット」や「エイリアス」です。例えば、`npm run build` と打つだけで、実際にはもっと長いビルドコマンド (`tsc` や `react-scripts build`) が実行されるように設定できます。これにより、プロジェクトのビルド、テスト、デプロイなどの作業を簡単かつ統一的に行えるようになります。
*   **技術的な解説:**
    *   **定義:** [`package.json`](#packagejson) ファイルの `scripts` オブジェクト内で定義される、キー (スクリプト名) と値 (実行されるシェルコマンド) のペアです。`npm run <script_name>` (または `build`, `start`, `test`, `stop` などの一部の標準スクリプト名は `npm <script_name>`) で実行できます。プロジェクトのビルド、テスト、リンティング、デプロイ、ローカル開発サーバーの起動など、開発ワークフローにおける一般的なタスクを自動化・標準化するためによく使用されます。`pre` や `post` プレフィックスを持つスクリプト (例: `prebuild`, `postinstall`) は、対応するスクリプトの前後に自動的に実行されます。
    *   **プロジェクトでの役割:**
        *   ルート (`simplechat/package.json`): `build` ([tsc](#tsc) の実行), `watch` (tsc の監視モード), `test` ([jest](#jest) の実行), CDK 関連コマンド (`deploy`, `destroy`, `synth`, `bootstrap`) のショートカット, [`postinstall`](#postinstall-npm-script) (フロントエンドのセットアップ自動化) が定義されています。
        *   フロントエンド (`simplechat/frontend/package.json`): [`react-scripts`](#react-scripts-react-scripts) を使用した `start` (開発サーバー起動), `build` (本番ビルド), `test` (テスト実行), `eject` が定義されています。
*   **関連:** [npm](#npm-node-package-manager), [package.json](#packagejson), 自動化, ビルドプロセス, テスト, コマンドライン

**Shebang (シバン)**
*   **初心者向け解説:** スクリプトファイル（特に Unix 系の OS で使われる）の最初の行に書かれる特別な記号 (`#!`) と、その後に続くインタプリタ（プログラム実行ツール）のパスです。OS に対して、「このファイルを実行するときは、このツール（例えば Node.js や Python）を使ってください」と指示する役割があります。
*   **技術的な解説:**
    *   **定義:** スクリプトファイルの先頭に書かれる `#!` から始まる行 (例: `#!/usr/bin/env node`, `#!/bin/bash`) で、そのスクリプトを実行するインタプリタを指定します。Unix ライクなオペレーティングシステムにおいて、スクリプトファイルに実行権限が付与されている場合、ファイル名を直接コマンドとして実行すると、カーネルが Shebang 行を解釈し、指定されたインタプリタを起動してスクリプトファイルを引数として渡します。
    *   **プロジェクトでの役割:** `simplechat/bin/bedrock-chatbot.ts` ファイルの先頭にある `#!/usr/bin/env node` は、この TypeScript ファイル (実際には `ts-node` を介して実行される) を [Node.js](#nodejs) インタプリタで実行することを示します。これにより、`cdk.json` の `app` コマンドなどでこのファイルを直接指定して実行できます。
*   **関連:** スクリプト, インタプリタ, Unix, Linux, macOS, [Node.js](#nodejs)

**source-map-support**
*   **初心者向け解説:** [TypeScript](#typescript) など、元のコード（人間が書いたコード）を別のコード（JavaScript など、コンピュータが実行するコード）に変換（トランスパイル）する場合、エラーが発生したときに、元のコードのどの行で問題が起きたのかが分かりにくくなることがあります。このツールは、エラーメッセージの行番号などを、変換後のコードではなく、元のコードに対応付けて表示してくれるため、デバッグ（バグ修正）作業がしやすくなります。
*   **技術的な解説:**
    *   **定義:** Node.js アプリケーションでソースマップ (Source Map) を利用して、トランスパイルされた JavaScript コードで発生したエラーのスタックトレースを、元のソースコード (例: TypeScript, ESNext JavaScript) のファイル名と行番号にマッピングするためのライブラリです。
    *   **プロジェクトでの役割:** [AWS CDK](#aws-cdk-cloud-development-kit) のコードは TypeScript で書かれ、JavaScript にトランスパイルされて Node.js で実行されます。`simplechat/bin/bedrock-chatbot.ts` で `import 'source-map-support/register';` が行われており、また `ConfigGeneratorFunction` Lambda の環境変数 `NODE_OPTIONS` でも `--enable-source-maps` が指定されています (Node.js v14 以降の組み込み機能)。これにより、CDK コードの実行中や Lambda 関数内でエラーが発生した場合に、出力されるスタックトレースが元の `.ts` ファイルの行番号を指し示すようになり、デバッグが容易になります。このライブラリ自体も `simplechat/package.json` の `dependencies` に含まれています。
*   **関連:** デバッグ, [TypeScript](#typescript), [Node.js](#nodejs), ソースマップ, トランスパイル, [package.json](#packagejson)

**SRP (Secure Remote Password)**
*   **初心者向け解説:** ユーザーがログインする際に、パスワードそのものをネットワーク上に送信することなく、安全に認証を行うための高度な「パスワード認証方式」の一つです。パスワードが途中で盗み見られたり、サーバー側に平文で保存されたりするリスクを低減します。[Amazon Cognito](#amazon-cognito) はこの安全な認証方式をサポートしています。
*   **技術的な解説:**
    *   **定義:** パスワード自体をネットワーク上で送信することなく、クライアントとサーバー間でパスワードベースの認証を行うための安全なパスワード認証プロトコル (RFC 2945)。ゼロ知識証明の考え方に基づいており、盗聴 (eavesdropping) やリプレイ攻撃 (replay attacks) に対して耐性があります。サーバーはパスワードの代わりに、パスワードから派生した検証値 (verifier) を保存します。認証プロセスでは、クライアントとサーバーがソルトと公開鍵を交換し、共有秘密鍵を計算して互いを認証します。
    *   **プロジェクトでの役割:** [Amazon Cognito](#amazon-cognito) は SRP 認証フローをサポートしており、`simplechat/lib/bedrock-chatbot-stack.ts` の [UserPool Client](#userpool-client-cognito) 設定で `authFlows: { userSrp: true }` として SRP 認証フローが有効化されています (Cognito のデフォルト)。フロントエンドの [Amplify Auth](#amplify-auth) ライブラリ (`Auth.signIn()`) などが、Cognito との認証時にこの SRP プロトコルを内部的に利用して、ユーザーのパスワードを直接ネットワークに送信することなく、安全な認証を実現しています。
*   **関連:** [Amazon Cognito](#amazon-cognito), 認証, セキュリティ, パスワード, 暗号プロトコル, [Amplify Auth](#amplify-auth)

**State (React)**
*   **初心者向け解説:** [React](#react) のコンポーネント（UI 部品）が内部で保持している、「時間とともに変化する可能性のあるデータ」のことです。例えば、チャットのメッセージ履歴、ユーザーが入力中のテキスト、ローディング中かどうかを示すフラグなどが State にあたります。State の値が変わると、React は自動的に画面の関連する部分を再描画して、表示を最新の状態に更新します。関数コンポーネントでは `useState` という [React Hooks](#react-hooks) を使って管理します。
*   **技術的な解説:**
    *   **定義:** [React](#react) [コンポーネント](#component-react)が自身の内部で保持し、時間とともに変化する可能性のあるデータです。State の更新は通常、イベントハンドラーや副作用の中で `setState` (クラスコンポーネント) または `useState` フックが返す更新関数 (関数コンポーネント) を呼び出すことによって行われます。State が更新されると、React はコンポーネントとその子コンポーネントの再レンダリングをスケジュールし、UI を更新します。State はコンポーネントにローカルであり、親から Props として渡されるデータとは区別されます。
    *   **プロジェクトでの役割:** `simplechat/frontend/src/App.js` の `ChatInterface` コンポーネントでは、`useState` フックを使用して以下の4つの状態変数が管理されています。
        *   `messages`: チャットの[会話履歴](#conversation-history)を格納する配列。新しいメッセージが追加されると更新されます。
        *   `input`: ユーザーがテキストエリアに入力中のテキスト。`onChange` イベントで更新されます。
        *   `loading`: バックエンド API との通信中かどうかを示すブーリアン値。API リクエスト開始時に `true`、応答受信時またはエラー時に `false` になります。
        *   `error`: API 通信などでエラーが発生した場合のエラーメッセージ文字列。エラー発生時に設定され、表示に使われます。
    これらの State の値が変化すると、`ChatInterface` コンポーネントが再レンダリングされ、画面表示 (メッセージリスト、入力欄、ローディング表示、エラー表示など) が更新されます。
*   **関連:** [React](#react), [Component (React)](#component-react), [React Hooks](#react-hooks) (useState), UI 更新, データ管理

**Tags (タグ)**
*   **初心者向け解説:** AWS 上に作成した様々なリソース（部品、サービス）に、目印として付けられる「ラベル」のことです。キー（項目名、例: `Project`）と値（内容、例: `SimpleChat`) のペアで設定します。たくさんのリソースがある場合に、特定のプロジェクトに関連するものだけを分類したり、コスト（料金）を部署ごとに集計したり、特定のタグが付いたリソースだけにアクセス許可を与えたりするなど、整理や管理に役立ちます。
*   **技術的な解説:**
    *   **定義:** AWS リソースに付与できるキーと値のペアのメタデータラベルです。大文字と小文字が区別されます。
    *   **プロジェクトでの役割:** リソースの整理、コスト配分、アクセス制御 (IAM ポリシーやサービスコントロールポリシーでの条件キーとして使用) など、様々な目的で利用されます。`simplechat/bin/bedrock-chatbot.ts` では `cdk.Tags.of(app).add('Project', 'SimpleChat')` や `cdk.Tags.of(app).add('Environment', 'Development')` (仮) のように `cdk.Tags.of(scope).add(key, value)` API を使って、CDK アプリケーション (`app`) スコープでタグを付与しています。これにより、この CDK アプリケーションによって作成されるすべてのタグ付け可能なリソース (例: Lambda 関数, S3 バケット, API Gateway など) に、デフォルトでこれらのタグ (`Project=SimpleChat`, `Environment=Development`) が付与されます。AWS Management Console でリソースをフィルタリングしたり、Cost Explorer でコストを分析したりする際に役立ちます。
*   **関連:** AWS リソース管理, コスト管理, アクセス制御, メタデータ, [AWS CDK](#aws-cdk-cloud-development-kit)

**Token (LLM)**
*   **初心者向け解説:** 大規模言語モデル (LLM) がテキスト（文章）を処理する際の、「最小単位」のことです。多くの場合、単語そのものではなく、単語の一部や、よく使われる単語全体、句読点などが1トークンとして数えられます。例えば、"chatbot" は "chat" と "bot" の2トークンかもしれません。LLM が一度に扱えるテキストの長さ（コンテキストウィンドウ）や、利用料金は、このトークン数に基づいて計算されることが多いです。
*   **技術的な解説:**
    *   **定義:** 大規模言語モデル (LLM) がテキストを内部的に表現し、処理する際の基本的な単位です。単語、サブワード (単語の一部、例: "ing", "est")、文字、句読点などがトークンになり得ます。テキストは、トークナイザー (Tokenizer) と呼ばれるアルゴリズム (例: BPE, WordPiece, SentencePiece) によってトークンのシーケンスに分割されます。モデルの入力長 (コンテキストウィンドウサイズ)、出力長、および多くの場合 API の利用料金は、このトークン数に基づいて計算されます。
    *   **プロジェクトでの役割:** [Amazon Bedrock](#amazon-bedrock) の API を呼び出す際、特に[推論パラメータ](#inference-parameters-bedrock) の `maxTokens` (またはモデル固有の類似パラメータ) は、モデルが生成する応答の最大トークン数を指定します。これにより、応答が長くなりすぎるのを防いだり、コストを制御したりします。また、モデルに入力する[会話履歴](#conversation-history)やプロンプトの合計トークン数が、モデルが扱える最大コンテキスト長を超えないように考慮する必要があります。
*   **関連:** [LLM (大規模言語モデル)](#llm-large-language-model), [Amazon Bedrock](#amazon-bedrock), [Inference Parameters (Bedrock)](#inference-parameters-bedrock), トークナイゼーション, コンテキストウィンドウ, 自然言語処理 (NLP)

**tsc**
*   **初心者向け解説:** [TypeScript](#typescript) というプログラミング言語で書かれたコードを、ウェブブラウザや [Node.js](#nodejs) が直接実行できる [JavaScript](#javascript) という言語のコードに「翻訳（コンパイル）」するためのコマンドラインツール（命令）です。TypeScript ファイル (`.ts`, `.tsx`) を入力として、JavaScript ファイル (`.js`) を出力します。
*   **技術的な解説:**
    *   **定義:** [TypeScript](#typescript) コンパイラのコマンドラインインターフェース (CLI) です。TypeScript コード (`.ts`, `.tsx` ファイル) を JavaScript コード (`.js` ファイル) に変換 (トランスパイル) します。コンパイルオプションは `tsconfig.json` ファイルで設定されます。型チェックのみを行う (`--noEmit`)、変更を監視して自動コンパイルする (`-w`, `--watch`) などの機能も持ちます。
    *   **プロジェクトでの役割:** ルートの `simplechat/package.json` の `devDependencies` に `typescript` パッケージ (tsc コマンドを含む) が含まれており、`scripts` セクションで利用されています。
        *   `"build": "tsc"`: `npm run build` コマンドを実行すると `tsc` が呼び出され、`tsconfig.json` の設定に従って `simplechat/bin/` と `simplechat/lib/` ディレクトリ内の TypeScript コードが JavaScript コードにコンパイルされ、通常は `tsconfig.json` の `outDir` で指定されたディレクトリ (このプロジェクトでは指定されていないため、`.ts` ファイルと同じ場所に `.js` ファイルが生成されるか、デフォルトの挙動に従う) に出力されます。
        *   `"watch": "tsc -w"`: `npm run watch` を実行すると、TypeScript ファイルの変更を監視し、変更があるたびに自動的にコンパイルが実行されます。これは開発中に便利です。
*   **関連:** [TypeScript](#typescript), コンパイラ, トランスパイル, ビルドプロセス, [package.json](#packagejson), [tsconfig.json](#tsconfigjson), JavaScript

**ts-node**
*   **初心者向け解説:** [TypeScript](#typescript) で書かれたコードを、事前に [JavaScript](#javascript) に翻訳（コンパイル）する手間なく、直接 [Node.js](#nodejs) で実行できるようにするための便利なツールです。開発中に TypeScript コードをすぐに試したり、CDK のように TypeScript で書かれた設定ファイルを直接実行したりするのに役立ちます。
*   **技術的な解説:**
    *   **定義:** [TypeScript](#typescript) を事前に JavaScript にコンパイルするステップを経ずに、[Node.js](#nodejs) 上で直接実行できるようにする TypeScript 実行エンジンおよび REPL (Read-Eval-Print Loop) です。内部的には、TypeScript コードをメモリ内で JavaScript に JIT (Just-In-Time) コンパイルして実行します。開発時の実行やスクリプティング、テストなどに便利です。
    *   **プロジェクトでの役割:** [`cdk.json`](#cdkjson) の `app` キーで `npx ts-node --prefer-ts-exts bin/bedrock-chatbot.ts` と指定されています。これにより、CDK Toolkit (`cdk deploy` や `cdk synth` などのコマンド) が実行される際に、`npx` を介して `ts-node` が呼び出され、TypeScript で書かれた CDK アプリケーションのエントリーポイント (`bin/bedrock-chatbot.ts`) が直接実行されます。`--prefer-ts-exts` オプションは、インポート時に `.js` よりも `.ts` ファイルを優先することを示します。`ts-node` はルートの `simplechat/package.json` の `devDependencies` に含まれています。
*   **関連:** [TypeScript](#typescript), [Node.js](#nodejs), [AWS CDK](#aws-cdk-cloud-development-kit), [cdk.json](#cdkjson), [package.json](#packagejson), REPL, JIT コンパイル

**tsconfig.json**
*   **初心者向け解説:** [TypeScript](#typescript) コンパイラ ([tsc](#tsc)) が、TypeScript コードをどのように JavaScript コードに翻訳（コンパイル）するかの「設定指示書」ファイルです。どのバージョンの JavaScript に変換するか、どのファイルを含める/除外するか、型チェックの厳しさなどを細かく設定できます。
*   **技術的な解説:** TypeScript プロジェクトのルートディレクトリに置かれる JSON ファイルで、TypeScript コンパイラ (tsc) のオプションと、コンパイル対象となるファイルを指定します。`compilerOptions` (ターゲットとする JavaScript バージョン `target`, モジュールシステム `module`, 出力ディレクトリ `outDir`, ソースマップ生成 `sourceMap`, 型チェックの厳格さ `strict` など) や、`include`, `exclude`, `files` (コンパイル対象ファイルの指定) などのトップレベルプロパティを持ちます。
*   **プロジェクトでの役割:** ルートディレクトリ (`simplechat/`) に `tsconfig.json` が存在し、CDK アプリケーションの TypeScript コード (`simplechat/bin`, `simplechat/lib`) のコンパイル設定を定義しています。`target`, `module`, `lib` で生成される JavaScript の互換性や機能を指定し、`strict` や関連オプションで型チェックの厳格さを設定しています。`sourceMap` を有効にしてデバッグをしやすくしています。`exclude` で `node_modules` や `cdk.out` (CDK のビルド成果物ディレクトリ) をコンパイル対象から除外しています。`npm run build` や `npm run watch` で `tsc` が実行される際、および `ts-node` がコードを実行する際に、このファイルの設定が参照されます。
*   **関連:** [TypeScript](#typescript), [tsc](#tsc), コンパイラ, 設定ファイル, JSON

**TypeScript**
*   **初心者向け解説:** Microsoft が開発した、[JavaScript](#javascript) を拡張したプログラミング言語です。JavaScript の機能に加えて、「型」という概念を導入しています。「型」とは、データ（数値、文字列、真偽値など）の種類をあらかじめ決めておくことで、プログラムの間違いを早期に発見しやすくしたり、コードの意図を明確にしたりするのに役立ちます。書かれたコードは最終的に JavaScript に変換（トランスパイル）されて実行されます。このプロジェクトでは、AWS CDK のコードが TypeScript で書かれています。
*   **技術的な解説:**
    *   **定義:** Microsoft によって開発された、JavaScript に静的型付け (static typing)、クラスベースオブジェクト指向、インターフェースなどの機能を追加したオープンソースのプログラミング言語です。JavaScript のスーパーセットであり、既存の JavaScript コードは有効な TypeScript コードでもあります。TypeScript コンパイラ ([tsc](#tsc)) によって JavaScript コードにトランスパイルされます。静的型チェックにより、コンパイル時に型エラーを検出でき、コードの堅牢性、保守性、開発効率 (エディタの補完やリファクタリング支援) を向上させます。
    *   **プロジェクトでの役割:** このプロジェクトでは、[AWS CDK](#aws-cdk-cloud-development-kit) のコード (インフラ定義) が `simplechat/bin/` と `simplechat/lib/` ディレクトリ内で TypeScript (`.ts` ファイル) で記述されています。静的型付けにより、CDK の各コンストラクトや API を使用する際に型エラーを開発中に検出し、予期せぬ設定ミスを防ぐのに役立っています。コンパイラ ([tsc](#tsc)) はルートの `simplechat/package.json` の `devDependencies` で管理され、`scripts` (`build`, `watch`) で使用されます。また、[`ts-node`](#ts-node) によって CDK コマンド実行時に直接実行されます。
*   **関連:** JavaScript, プログラミング言語, 静的型付け, [AWS CDK](#aws-cdk-cloud-development-kit), [tsc](#tsc), [tsconfig.json](#tsconfigjson), [package.json](#packagejson), トランスパイル

**UserPool (Cognito)**
*   **初心者向け解説:** [Amazon Cognito](#amazon-cognito) の中で、アプリケーションのユーザーアカウント情報（ユーザー名、パスワード、メールアドレスなど）をまとめて管理するための「会員名簿」のようなものです。パスワードの強度ルールや、サインアップ（新規登録）を許可するかどうかなどの設定もここで行います。
*   **技術的な解説:**
    *   **定義:** [Amazon Cognito](#amazon-cognito) におけるユーザーディレクトリです。ユーザーアカウント、属性 (標準属性およびカスタム属性)、認証設定 (MFA、パスワードポリシー、サインアップ/サインイン方法)、フェデレーション (外部 ID プロバイダー連携) などを管理します。アプリケーションは [UserPool Client](#userpool-client-cognito) を介して UserPool と対話します。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` で `ChatbotUserPool` という名前の Cognito UserPool が `new cognito.UserPool(...)` として作成されています。設定として、`userPoolName`, `signInAliases: { email: true }` (Eメールアドレスでのサインインを許可), `selfSignUpEnabled: true` (ユーザー自身によるサインアップを許可), `passwordPolicy` (パスワードの最小長や必要な文字種), `removalPolicy: cdk.RemovalPolicy.DESTROY` (CDK スタック削除時にユーザープールも削除する) などが定義されています。
*   **関連:** [Amazon Cognito](#amazon-cognito), ユーザー認証, ユーザー管理, ディレクトリサービス, [UserPool Client (Cognito)](#userpool-client-cognito)

**UserPool Client (Cognito)**
*   **初心者向け解説:** [UserPool](#userpool-cognito) (会員名簿) に、特定のアプリケーション（例えばこのチャットアプリのフロントエンド）がアクセスするための「専用窓口」の設定です。どのアプリからのアクセスを許可するか、そのアプリがどのような認証方法（例: [SRP](#srp-secure-remote-password)）を使えるか、ログイン後にどの情報へのアクセスを許可するか ([OAuth Scope](#oauth-scope-cognito)) などを定義します。アプリごとにクライアント設定を作成することで、セキュリティを高めます。
*   **技術的な解説:**
    *   **定義:** アプリケーションが [Cognito UserPool](#userpool-cognito) と対話するためのインターフェースと設定のセットです。特定のアプリケーション (例: ウェブアプリ, モバイルアプリ) ごとに作成されます。クライアント ID が発行され、クライアントシークレット (オプション) を持つこともあります。認証フロー (例: `userSrp`, `adminUserPassword`), 許可される [OAuth 2.0](#oauth-20) フロー (`implicit`, `code`)、許可される [OAuth Scope](#oauth-scope-cognito), ID トークン/Access トークンの有効期間、コールバック URL などを設定します。
    *   **プロジェクトでの役割:** `simplechat/lib/bedrock-chatbot-stack.ts` で `ChatbotUserPoolClient` という名前の Cognito UserPool Client が `new cognito.UserPoolClient(...)` として作成されています。これは、フロントエンドの [React](#react) アプリケーション ([Amplify](#aws-amplify) ライブラリ経由) が `ChatbotUserPool` と対話するために使用されます。設定として、`userPool`, `userPoolClientName`, `authFlows: { userSrp: true }` ([SRP](#srp-secure-remote-password) 認証フローを有効化), `oAuth` 設定 (許可する OAuth フロー、スコープ、コールバック URL など) が定義されています。フロントエンドの Amplify 設定 (`aws-exports.js` または `config.js` 経由) にはこのクライアント ID (`userPoolWebClientId`) が含まれ、Amplify ライブラリが認証処理を行う際に使用します。
*   **関連:** [Amazon Cognito](#amazon-cognito), [UserPool (Cognito)](#userpool-cognito), 認証, [OAuth 2.0](#oauth-20), [OAuth Scope (Cognito)](#oauth-scope-cognito), [SRP (Secure Remote Password)](#srp-secure-remote-password), [AWS Amplify](#aws-amplify)

**web-vitals**
*   **初心者向け解説:** ウェブページの「使い心地の良さ」（ユーザーエクスペリエンス）を測るための指標（Core Web Vitals など）を、実際にユーザーがページを使っているときに計測するための JavaScript ライブラリです。ページの読み込み速度、クリックなどへの反応速度、表示の安定性などを計測し、改善点を見つけるのに役立ちます。[Create React App](#create-react-app-cra) にはデフォルトで含まれていることがあります。
*   **技術的な解説:**
    *   **定義:** Google が提唱する Core Web Vitals (LCP: Largest Contentful Paint, FID: First Input Delay / INP: Interaction to Next Paint, CLS: Cumulative Layout Shift) をはじめとする、ウェブページのユーザーエクスペリエンス品質に関する重要な指標を測定するための JavaScript ライブラリです。`onLCP`, `onFID`, `onCLS`, `onINP`, `onTTFB` といった関数を提供し、これらの指標が利用可能になった時点でコールバック関数を実行します。
    *   **プロジェクトでの役割:** `simplechat/frontend/package.json` の `dependencies` に `web-vitals` が含まれており、[Create React App](#create-react-app-cra) の標準セットアップの一部として組み込まれています。通常、`src/reportWebVitals.js` ファイル (このリポジトリには存在しないようです) でこのライブラリがインポートされ、計測された指標データを Google Analytics などの分析ツールに送信するロジックが実装されます。これにより、実際のユーザー環境でのページのパフォーマンスを把握し、改善に役立てることができます。現状では明示的に使用されているコードは見当たりませんが、ライブラリとしては導入されています。
*   **関連:** [フロントエンド](#フロントエンド-frontend), パフォーマンスモニタリング, Core Web Vitals, [Create React App (CRA)](#create-react-app-cra), ユーザーエクスペリエンス

--- END OF REVISED FILE 用語集.md ---